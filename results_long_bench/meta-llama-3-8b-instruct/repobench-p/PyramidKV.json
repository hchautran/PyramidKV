{"prompt": "Please complete the code given below. \nsrc/main/java/waterwave/proxy/router/ProxyRouter.java\npublic class ProxyRouter {\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\t// TODO Auto-generated method stub\r\n\r\n\t}\r\n\r\n\tpublic static SocketAddress staticRemote;\r\n\tpublic static InetAddress staticRemoteIp;\r\n\tpublic static int staticRemotePort;\r\n\tpublic static SocketAddress getStaticRemote() {\r\n\t\t// TODO Auto-generated method stub\r\n\t\treturn staticRemote;\r\n\t}\r\n\r\n}\r\nsrc/main/java/shui/common/util/CommonUtil.java\npublic class CommonUtil {\r\n\tpublic static String getLocalIp() {\r\n\t\tInetAddress addr;\r\n\t\ttry {\r\n\t\t\taddr = InetAddress.getLocalHost();\r\n\t\t\tString ip = addr.getHostAddress().toString();\r\n\t\t\treturn ip;\r\n\t\t} catch (UnknownHostException e) {\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t\treturn null;\r\n\r\n\t}\r\n\t\r\n\tpublic final static String getStringFromException(Throwable e) {\r\n\r\n\t\tStringWriter sw = new StringWriter();\r\n\t\tPrintWriter ps = new PrintWriter(sw);\r\n\r\n\t\te.printStackTrace(ps);\r\n\r\n\t\treturn sw.toString();\r\n\t}\r\n}\r\nsrc/main/java/shui/common/service/ThreadSharedService.java\npublic class ThreadSharedService {\r\n\tprotected final Logger log = new SimpleLogger(true);\r\n\t\r\n\tpublic static void main(String[] args) {\r\n\r\n\t}\r\n\r\n}\r\nsrc/main/java/waterwave/net/aio/AioClient.java\npublic final class AioClient extends AioService implements Runnable {\r\n\r\n\t// private final AsynchronousSocketChannel listener;\r\n\tprivate final AsynchronousChannelGroup channelGroup;\r\n\tprivate final AioDataDealerFactory aioDataDealerFactory;\r\n\t\r\n\tprivate final Map<Integer, AioServerChannel> connections = new ConcurrentHashMap<Integer, AioServerChannel>();\r\n\t\r\n\r\n\tpublic AioClient(ExecutorService channelWorkers, AioDataDealerFactory aioDataDealerFactory) throws IOException {\r\n\t\t// ExecutorService channelWorkers = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors(), Executors.defaultThreadFactory());\r\n\t\tchannelGroup = AsynchronousChannelGroup.withThreadPool(channelWorkers);\r\n\t\tthis.aioDataDealerFactory = aioDataDealerFactory;\r\n\t}\r\n\r\n\tclass AcceptHandler implements CompletionHandler<Void, Void> {\r\n\t\tprivate final AsynchronousSocketChannel listener;\r\n\t\tprivate final AioClientDataDealer aioClientDataDealer;\r\n\r\n\t\tpublic AcceptHandler(AsynchronousSocketChannel listener, AioClientDataDealer aioClientDataDealer) {\r\n\t\t\tsuper();\r\n\t\t\tthis.listener = listener;\r\n\t\t\tthis.aioClientDataDealer = aioClientDataDealer;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic void completed(Void result, Void attachment) {\r\n\t\t\t//log.log(1, \"Client AcceptHandler connected \");\r\n\t\t\thandleNewConnection(listener, aioClientDataDealer);\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic void failed(Throwable exc, Void attachment) {\r\n\t\t\t//log.log(1, \"Client AcceptHandler failed result: \" + exc);\r\n\t\t}\r\n\r\n\t}\r\n\t\r\n\tpublic AsynchronousSocketChannel connect(SocketAddress remote) throws IOException {\r\n\t\treturn connect(remote, null);\r\n\t}\r\n\tpublic AsynchronousSocketChannel connect(SocketAddress remote, AioClientDataDealer aioClientDataDealer) throws IOException {\r\n\t\tAsynchronousSocketChannel listener = createListener(channelGroup);\r\n\t\t//log.log(1, \"client start connect\");\r\n\r\n\t\tAcceptHandler acceptHandler = new AcceptHandler(listener, aioClientDataDealer);\r\n\r\n\t\tlistener.connect(remote, null, acceptHandler);\r\n\t\treturn listener;\r\n\t}\r\n\r\n\tprotected void handleNewConnection(AsynchronousSocketChannel channel, AioClientDataDealer aioClientDataDealer) {\r\n\t\tif (!channel.isOpen()) {\r\n\t\t\t//log.log(1, \"handleNewConnection closed.. \");\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\tAioClientDataDealer dealer = null;\r\n\t\tif (aioClientDataDealer != null) {\r\n\t\t\tdealer = aioClientDataDealer;\r\n\t\t} else {\r\n\t\t\taioDataDealerFactory.getAioClientDataDealer();\r\n\t\t}\r\n\r\n\t\tint channelId = getChannelId();\r\n\t\tAioClientChannel aioChannel = new AioClientChannel(channelId, channel, dealer, this);\r\n\t\t\r\n\t\t// connections.add(aioChannel);\r\n\t\taioChannel.run(null);\r\n\t\t\r\n\t\tdealer.clientOnConnect(aioChannel);\r\n\r\n\t\t// String w = \"GET / HTTP/1.1 \\n\\n\";\r\n\t\t// ByteBuffer buffer = ByteBuffer.wrap(w.getBytes());\r\n\t\t// System.out.println(\"set write \");\r\n\t\t// channel.write(buffer, buffer, new CompletionHandler<Integer, ByteBuffer>() {\r\n\t\t// @Override\r\n\t\t// public void completed(Integer result, ByteBuffer buffer) {\r\n\t\t// if (buffer.hasRemaining()) {\r\n\t\t// System.out.println(\"write... \");\r\n\t\t// channel.write(buffer, buffer, this);\r\n\t\t// } else {\r\n\t\t// // Go back and check if there is new data to write\r\n\t\t// // writeFromQueue();\r\n\t\t// System.out.println(\"write complete \" + result);\r\n\t\t// }\r\n\t\t// }\r\n\t\t//\r\n\t\t// @Override\r\n\t\t// public void failed(Throwable exc, ByteBuffer attachment) {\r\n\t\t// }\r\n\t\t// });\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * \r\n\t * \r\n\t * @param channelGroup\r\n\t * @return\r\n\t * @throws IOException\r\n\t * \r\n\t * \r\n\t *             SO_SNDBUF The size of the socket send buffer .\r\n\t *             SO_RCVBUF The size of the socket receive buffer. \r\n\t *             SO_KEEPALIVE Keep connection alive. \r\n\t *             SO_REUSEADDR Re-use address .\r\n\t *             TCP_NODELAY Disable the Nagle algorithm.\r\n\t * \r\n\t * \r\n\t */\r\n\tprivate AsynchronousSocketChannel createListener(AsynchronousChannelGroup channelGroup) throws IOException {\r\n\t\tfinal AsynchronousSocketChannel listener = AsynchronousSocketChannel.open(channelGroup);\r\n\t\t//TODO\r\n\t\t//listener.setOption(StandardSocketOptions.TCP_NODELAY, true);\r\n\t\tlistener.setOption(StandardSocketOptions.SO_REUSEADDR, true);\r\n\t\tlistener.setOption(StandardSocketOptions.SO_RCVBUF, 16 * 1024);\r\n\t\tlistener.setOption(StandardSocketOptions.SO_SNDBUF, 16 * 1024);\r\n\t\treturn listener;\r\n\t}\r\n\r\n\t//for test\r\n\t@Override\r\n\tpublic void run() {\r\n\t\tSystem.out.println(Thread.currentThread().getName() + \"---run\");\r\n\r\n\t\tInetSocketAddress r = new InetSocketAddress(\"10.213.33.176\", 11200);\r\n\t\ttry {\r\n\t\t\tAsynchronousSocketChannel channel = connect(r);\r\n\t\t\tSystem.out.println(channel);\r\n\t\t} catch (IOException e) {\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * \r\n\t */\r\n\tprivate AtomicInteger channelId = new AtomicInteger();\r\n\tprivate int getChannelId() {\r\n\t\treturn channelId.incrementAndGet();\r\n\t}\r\n\r\n\tpublic void removeAioChannel(AioClientChannel client) {\r\n       connections.remove(client.getChannelId());\r\n\t}\r\n\t\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\ttry {\r\n\t\t\tint threadCap = 4;\r\n\t\t\tExecutorService channelWorkers = Executors.newFixedThreadPool(threadCap, Executors.defaultThreadFactory());\r\n\t\t\tAioClient c = new AioClient(channelWorkers, null);\r\n\t\t\tc.run();\r\n\r\n\t\t\tThread.sleep(100000);\r\n\r\n\t\t} catch (Exception e) {\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\nsrc/main/java/waterwave/net/aio/AioClientChannel.java\npublic final class AioClientChannel extends AioChannel{\r\n\t\r\n\tprivate final AsynchronousSocketChannel channel;\r\n\tprivate final AioClientDataDealer dealer;\r\n\t\r\n\tprivate final AioClient aioClient;\r\n\tprivate final int channelId;\r\n\t\r\n\t\r\n\t\r\n\r\n\tpublic AsynchronousSocketChannel getChannel() {\r\n\t\treturn channel;\r\n\t}\r\n\r\n\tpublic int getChannelId() {\r\n\t\treturn channelId;\r\n\t}\t\r\n\r\n\tpublic AioClientChannel(int channelId, AsynchronousSocketChannel channel, AioClientDataDealer dealer, AioClient aioClient) {\r\n\t\tthis.channelId = channelId;\r\n\t\tthis.channel = channel;\r\n\t\tthis.dealer = dealer;\r\n\t\tthis.aioClient = aioClient;\r\n\t}\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\t// TODO Auto-generated method stub\r\n\r\n\t}\r\n\r\n\tpublic void run(ReadHandler reader) {\r\n\t\tdealer.clientBeforeRead(this);\r\n\t\tif(reader == null){\r\n\t\t\t//new\r\n\t\t\treader = new ReadHandler(this);\r\n\t\t}\r\n\t\tread(reader);\r\n\t\t\r\n\t}\r\n\t\r\n\t/**\r\n     * Runs a cycle of doing a beforeRead action and then enqueuing a new\r\n     * read on the client. Handles closed channels and errors while reading.\r\n     * If the client is still connected a new round of actions are called.\r\n     */\r\n\tclass ReadHandler implements CompletionHandler<Integer, ByteBuffer>{\r\n\t\tAioClientChannel clientChannel;\r\n\t\t\r\n        public ReadHandler(AioClientChannel clientChannel) {\r\n\t\t\tsuper();\r\n\t\t\tthis.clientChannel = clientChannel;\r\n\t\t}\r\n\r\n        @Override\r\n\t\tpublic void completed(Integer result, ByteBuffer buffer) {\r\n\t\t\t// if result is negative or zero the connection has been closed or something gone wrong\r\n\t\t\t//log.log(1, \"client ReadHandler read success: \");\r\n\t\t\tif (result < 1) {\r\n\t\t\t\tclientChannel.close();\r\n\t\t\t\tdealer.clientOnClose(clientChannel);\r\n\t\t\t\t\r\n\t\t\t\t//log.log(1, \"result < 1 ReadHandler Closing connection to \" + channel);\r\n\t\t\t} else {\r\n//\t\t\t\tSystem.out.println(\"result: \" + result);\r\n//\t\t\t\t// callback.onData(client, buffer, result);\r\n//\t\t\t\tbuffer.flip();\r\n//\t\t\t\tString name;\r\n//\t\t\t\tname = new String(buffer.array(), 0, result);\r\n//\t\t\t\tSystem.out.println(\"data: \" + name);\r\n//\t\t\t\t// enqueue next round of actions\r\n//\t\t\t\t// client.run();\r\n\t\t\t\t\r\n\t\t\t\tdealer.clientOnData(clientChannel, buffer, result);\r\n                // enqueue next round of actions\r\n\t\t\t\tclientChannel.run(this);\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic void failed(Throwable e, ByteBuffer buffer) {\r\n\t\t\tlog.log(9, \"client ReadHandler read fail: \" + e);\r\n\t\t\t\r\n\t\t\tclientChannel.close();\r\n\t\t\tdealer.clientOnError(clientChannel, e, buffer);\r\n\t\t}\r\n\t\t\r\n//\t\tpublic void onData(AioServerChannel channel, ByteBuffer buffer, int bytes) {\r\n//\t        buffer.flip();\r\n//\t        // Just append the message on the buffer\r\n//\t        //AioServerChannel.appendMessage(new String(buffer.array(), 0, bytes));\r\n//\t    }\r\n\t\t\r\n\t}\r\n\t\r\n\tclass WriteHandler implements CompletionHandler<Integer, ByteBuffer>{\r\n\t\tAioClientChannel clientChannel;\r\n\t\t\r\n        public WriteHandler(AioClientChannel clientChannel) {\r\n\t\t\tsuper();\r\n\t\t\tthis.clientChannel = clientChannel;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic void completed(Integer result, ByteBuffer buffer) {\r\n\t\t\t// if result is negative or zero the connection has been closed or something gone wrong\r\n\t\t\t//log.log(1, \"client WriteHandler write success: \");\r\n\t\t\tif (buffer.hasRemaining()) {\r\n\t\t\t\t//log.log(1, \"client WriteHandler write...  hasRemaining \");\r\n\t\t\t\tchannel.write(buffer, buffer, this);\r\n\t\t\t} else {\r\n\t\t\t\t// Go back and check if there is new data to write\r\n\t\t\t\t// writeFromQueue();\r\n\t\t\t\t//log.log(1, \"client write complete \" + result);\r\n\r\n\t\t\t}\r\n\t\t\tdealer.clientAfterWrite(clientChannel, buffer, result);\r\n\t\t\t\r\n\t\t\tBufferTools.returnBuffer(buffer);\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic void failed(Throwable e, ByteBuffer buffer) {\r\n\t\t\tlog.log(9, \"client WriteHandler write fail: \" + e);\r\n\t\t\tclientChannel.close();\r\n\t\t}\r\n\t\t\r\n//\t\tpublic void onData(AioServerChannel channel, ByteBuffer buffer, int bytes) {\r\n//\t        buffer.flip();\r\n//\t        // Just append the message on the buffer\r\n//\t        //AioServerChannel.appendMessage(new String(buffer.array(), 0, bytes));\r\n//\t    }\r\n\t\t\r\n\t}\r\n\t\r\n    /**\r\n     * Enqueue a read\r\n     * @param completionHandler callback on completed read\r\n     */\r\n    public final void read(CompletionHandler<Integer, ? super ByteBuffer> completionHandler) {\r\n    \t//log.log(1, \"Cliet: start client read \");\r\n    \t\r\n        ByteBuffer input = BufferTools.getBuffer();\r\n        if (!channel.isOpen()) {\r\n            return;\r\n        }\r\n        channel.read(input, input, completionHandler);\r\n    }\r\n    \r\n    \r\n    private CompletionHandler<Integer, ? super ByteBuffer> writerHandler = null;\r\n    public final void write(final ByteBuffer input) {\r\n    \tif(this.writerHandler == null) {\r\n    \t\twriterHandler = new WriteHandler(this);\r\n    \t}\r\n    \twrite(input, writerHandler);\r\n    }\r\n    \r\n    /**\r\n     * Enqueue a read\r\n     * @param completionHandler callback on completed read\r\n     */\r\n    protected final void write(ByteBuffer b ,CompletionHandler<Integer, ? super ByteBuffer> completionHandler) {\r\n    \t//log.log(1, \"start client write \");\r\n    \t\r\n        if (!channel.isOpen()) {\r\n            return;\r\n        }\r\n        channel.write(b, b, completionHandler);\r\n    }\r\n    \r\n\r\n\tpublic void close() {\r\n        try {\r\n            channel.close();\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n        aioClient.removeAioChannel(this);\r\n\t\t\r\n\t\t\r\n\t}\r\n\r\n}\r\nsrc/main/java/waterwave/net/aio/AioServerChannel.java\npublic final class AioServerChannel extends AioChannel{\r\n\t\r\n\tprivate final AsynchronousSocketChannel channel;\r\n\tprivate final AioServerDataDealer dealer;\r\n\tprivate final AioServer aioServer;\r\n\tprivate final int channelId;\r\n    //private final Queue<ByteBuffer> queue = new LinkedList<ByteBuffer>();\r\n\tprivate final Queue<ByteBuffer> queue = null;\r\n    \r\n    private boolean writing = false;\r\n\t\r\n    \r\n\r\n\tpublic int getChannelId() {\r\n\t\treturn channelId;\r\n\t}\r\n\r\n\r\n\tpublic AioServerChannel(int channelId, AsynchronousSocketChannel channel, AioServerDataDealer dealer, AioServer aioServer) {\r\n\t\tdealer.serverOnConnect(this);\r\n\t\tthis.channel = channel;\r\n\t\tthis.dealer = dealer;\r\n\t\tthis.aioServer = aioServer;\r\n\t\tthis.channelId = channelId;\r\n\t}\r\n\r\n\r\n\tpublic void run(ReadHandler reader) {\r\n\t\tdealer.serverBeforeRead(this);\r\n\t\tif (reader == null) {\r\n\t\t\treader = new ReadHandler(this);\r\n\t\t}\r\n\t\tread(reader);\r\n\r\n\t}\r\n\t\r\n    /**\r\n     * Runs a cycle of doing a beforeRead action and then enqueuing a new\r\n     * read on the client. Handles closed channels and errors while reading.\r\n     * If the client is still connected a new round of actions are called.\r\n     */\r\n\tclass ReadHandler implements CompletionHandler<Integer, ByteBuffer>{\r\n\t\tAioServerChannel serverChannel;\r\n\t\t\r\n        public ReadHandler(AioServerChannel serverChannel) {\r\n\t\t\tsuper();\r\n\t\t\tthis.serverChannel = serverChannel;\r\n\t\t}\r\n\r\n\t\t@Override\r\n        public void completed(Integer result, ByteBuffer buffer) {\r\n            // if result is negative or zero the connection has been closed or something gone wrong\r\n            if (result < 1) {\r\n            \t//log.log(1, \"server:ReadHandler result < 1 Closing connection to \" + serverChannel);\r\n            \t\r\n            \tserverChannel.close();\r\n            \tdealer.serverOnClose(serverChannel);\r\n            \t\r\n            } else {\r\n            \tdealer.serverOnData(serverChannel, buffer, result);\r\n                // enqueue next round of actions\r\n                serverChannel.run(this);\r\n            }\r\n        }\r\n\r\n\t\t@Override\r\n\t\tpublic void failed(Throwable exc, ByteBuffer attachment) {\r\n\t\t\t// TODO Auto-generated method stub\r\n\t\t\tserverChannel.close();\r\n\t\t\t\r\n\t\t\tdealer.serverOnError(serverChannel, exc, attachment);\r\n\t\t}\r\n\t\t\r\n//\t\tpublic void onData(AioServerChannel channel, ByteBuffer buffer, int bytes) {\r\n//\t        buffer.flip();\r\n//\t        // Just append the message on the buffer\r\n//\t        //AioServerChannel.appendMessage(new String(buffer.array(), 0, bytes));\r\n//\t    }\r\n\t\t\r\n\t}\r\n\t\r\n    /**\r\n     * Enqueue a read\r\n     * @param completionHandler callback on completed read\r\n     */\r\n    public final void read(CompletionHandler<Integer, ? super ByteBuffer> completionHandler) {\r\n        ByteBuffer input = BufferTools.getBuffer();\r\n        if (!channel.isOpen()) {\r\n            return;\r\n        }\r\n        channel.read(input, input, completionHandler);\r\n    }\r\n    \r\n\r\n    \r\n\tclass WriteHandler implements CompletionHandler<Integer, ByteBuffer>{\r\n\t\tAioServerChannel serverChannel;\r\n\t\t\r\n        public WriteHandler(AioServerChannel serverChannel) {\r\n\t\t\tsuper();\r\n\t\t\tthis.serverChannel = serverChannel;\r\n\t\t}\r\n\r\n        @Override\r\n\t\tpublic void completed(Integer result, ByteBuffer buffer) {\r\n\t\t\t// if result is negative or zero the connection has been closed or something gone wrong\r\n\t\t\t//System.out.println(\"read success: \");\r\n\t\t\tif (buffer.hasRemaining()) {\r\n\t\t\t\t//log.log(1, \"server write... \");\r\n\t\t\t\tchannel.write(buffer, buffer, this);\r\n\t\t\t} else {\r\n\t\t\t\t// Go back and check if there is new data to write\r\n\t\t\t\t// writeFromQueue();\r\n\t\t\t\t//log.log(1, \"server write complete \" + result);\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\tdealer.serverAfterWrite(serverChannel, buffer, result);\r\n\t\t\tBufferTools.returnBuffer(buffer);\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic void failed(Throwable exc, ByteBuffer buffer) {\r\n\t\t\tlog.log(9, \"server WriteHandler write fail: \" + exc);\r\n\t\t\tserverChannel.close();\r\n\t\t}\r\n\t\t\r\n//\t\tpublic void onData(AioServerChannel channel, ByteBuffer buffer, int bytes) {\r\n//\t        buffer.flip();\r\n//\t        // Just append the message on the buffer\r\n//\t        //AioServerChannel.appendMessage(new String(buffer.array(), 0, bytes));\r\n//\t    }\r\n\t\t\r\n\t}\r\n    \r\n    \r\n\r\n    \r\n    private CompletionHandler<Integer, ? super ByteBuffer> writerHandler = null;\r\n    public final void write(final ByteBuffer input) {\r\n    \tif(this.writerHandler == null) {\r\n    \t\twriterHandler = new WriteHandler(this);\r\n    \t}\r\n    \twrite(input, writerHandler);\r\n    }\r\n    \r\n    /**\r\n     * Enqueue a read\r\n     * @param completionHandler callback on completed read\r\n     */\r\n    protected final void write(ByteBuffer b ,CompletionHandler<Integer, ? super ByteBuffer> completionHandler) {\r\n    \t//log.log(1, \"start server write \");\r\n    \t\r\n        if (!channel.isOpen()) {\r\n            return;\r\n        }\r\n        channel.write(b, b, completionHandler);\r\n    }\r\n    \r\n\r\n\r\n\t\r\n\t/**\r\n     * Closes the channel\r\n     */\r\n    public void close() {\r\n        try {\r\n            channel.close();\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n        aioServer.removeAioChannel(this);\r\n    }\r\n\r\n\r\n    \r\n    /**\r\n     * Enqueues a write of the buffer to the channel.\r\n     * The call is asynchronous so the buffer is not safe to modify after\r\n     * passing the buffer here.\r\n     *\r\n     * @param buffer the buffer to send to the channel\r\n     */\r\n    @Deprecated\r\n    public void writeOld(final ByteBuffer buffer) {\r\n        boolean threadShouldWrite = false;\r\n\r\n        synchronized(queue) {\r\n            queue.add(buffer);\r\n            // Currently no thread writing, make this thread dispatch a write\r\n            if (!writing) {\r\n                writing = true;\r\n                threadShouldWrite = true;\r\n            }\r\n        }\r\n\r\n        if (threadShouldWrite) {\r\n        \twriteFromQueueOld();\r\n        }\r\n    }\r\n    \r\n    @Deprecated\r\n    private void writeFromQueueOld() {\r\n        ByteBuffer buffer;\r\n\r\n        synchronized (queue) {\r\n            buffer = queue.poll();\r\n            if (buffer == null) {\r\n                writing = false;\r\n            }\r\n        }\r\n\r\n        // No new data in buffer to write\r\n        if (writing) {\r\n        \twriteBufferOld(buffer);\r\n        }\r\n    }\r\n    \r\n    @Deprecated\r\n    private void writeBufferOld(ByteBuffer buffer) {\r\n        channel.write(buffer, buffer, new CompletionHandler<Integer, ByteBuffer>() {\r\n            @Override\r\n            public void completed(Integer result, ByteBuffer buffer) {\r\n                if (buffer.hasRemaining()) {\r\n                    channel.write(buffer, buffer, this);\r\n                } else {\r\n                    // Go back and check if there is new data to write\r\n                \twriteFromQueueOld();\r\n                }\r\n            }\r\n\r\n            @Override\r\n            public void failed(Throwable exc, ByteBuffer attachment) {\r\n            }\r\n        });\r\n    }\r\n    \r\n    \r\n\r\n    /**\r\n     * Sends a message\r\n     * @param string the message\r\n     */\r\n    @Deprecated\r\n    public void writeStringMessageOld(String string) {\r\n    \twriteOld(ByteBuffer.wrap(string.getBytes()));\r\n    }\r\n\r\n    /**\r\n     * Send a message from a specific client\r\n     * @param client the message is sent from\r\n     * @param message to send\r\n     */\r\n    @Deprecated\r\n    public void writeMessageFromOld(AioServerChannel client, String message) {\r\n        if (dealer.serverAcceptsMessages()) {\r\n            //writeStringMessage(client.getUserName() + \": \" + message);\r\n        }\r\n    }\r\n    \r\n\r\n\t\r\n\r\n}\r\nsrc/main/java/waterwave/net/aio/define/AioServerDataDealer.java\npublic interface AioServerDataDealer {\r\n\t\r\n\tvoid serverOnConnect(AioServerChannel channel);\r\n    void serverBeforeRead(AioServerChannel channel);\r\n    void serverOnData(AioServerChannel channel, ByteBuffer buffer, int bytes);\r\n    void serverAfterWrite(AioServerChannel channel, ByteBuffer buffer, int bytes);\r\n    void serverOnError(AioServerChannel channel,Throwable exc, ByteBuffer attachment);\r\n    void serverOnClose(AioServerChannel channel);\r\n    boolean serverAcceptsMessages();\r\n    \r\n\r\n}\r\nsrc/main/java/shui/common/buffer/BufferTools.java\npublic class BufferTools {\r\n\r\n\tprivate final static BufferPoolNIO bp = new BufferPoolNIO(2 * 1024, 32 * 1024);\r\n\t\r\n\tpublic final static ByteBuffer getBuffer() {\r\n\t\t//ByteBuffer input = ByteBuffer.allocate(16 * 1024);\r\n\t\tByteBuffer input = bp.allocate();\r\n\t\treturn input;\r\n\t}\r\n\r\n\tpublic final static void returnBuffer(ByteBuffer buffer) {\r\n\t\tbp.recycle(buffer);\r\n\t\t\r\n\t}\r\n\tpublic final static byte[] getBuffer2Byte(ByteBuffer b) {\r\n\t\tint p = b.position();\r\n\t\tbyte[] r = new byte[p];\r\n\t\tif (b.position() != 0) {\r\n\t\t\tb.flip();\r\n\t\t}\r\n\t\tb.get(r, 0, p);\r\n\r\n\t\treturn r;\r\n\t}\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\t// TODO Auto-generated method stub\r\n\r\n\t}\r\n\r\n\r\n}\r\nsrc/main/java/waterwave/net/aio/define/AioClientDataDealer.java\npublic interface AioClientDataDealer {\r\n\r\n    \r\n\tvoid clientBeforeRead(AioClientChannel channel);\r\n\tvoid clientOnConnect(AioClientChannel channel);\r\n\tvoid clientOnData(AioClientChannel channel, ByteBuffer buffer, int result);\r\n\tvoid clientAfterWrite(AioClientChannel channel, ByteBuffer buffer, int bytes);\r\n\tvoid clientOnError(AioClientChannel channel,Throwable exc, ByteBuffer attachment);\r\n    void clientOnClose(AioClientChannel channel);\r\n\tboolean clientAcceptsMessages();\r\n}\r\nsrc/main/java/shui/common/log/Logger.java\npublic abstract class Logger {\r\n\r\n\tpublic String threadInfo = null;\r\n\tpublic int level;\r\n\r\n\tprotected boolean printTime = true;\r\n\tprotected boolean printThreadInfo = true;\r\n\r\n\tpublic Logger() {\r\n\t}\r\n\r\n\tpublic Logger(boolean printTime) {\r\n\t\tthis();\r\n\t\tthis.printTime = printTime;\r\n\t}\r\n\r\n\t\r\n\tpublic abstract void log(int level, Object o) ;\r\n\tpublic abstract void log(int level, Object... os) ;\r\n\tpublic abstract PrintWriter getErrorWriter();\r\n\r\n\r\n\tpublic final static void log(byte[] bs) {\r\n\t\tfor (byte b : bs) {\r\n\t\t\tlog1(b);\r\n\t\t\tlog1(\"\\t\");\r\n\t\t}\r\n\t\tlog(\"\\t\");\r\n\t}\r\n\t\r\n\t\r\n\tpublic final static void log1(Object o) {\r\n\t\tSystem.out.print(o);\r\n\t}\r\n\t\r\n\tpublic final static void log(Object o) {\r\n\t\tSystem.out.println(o);\r\n\t}\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\t// TODO Auto-generated method stub\r\n\r\n\t}\r\n\r\n}\r\nimport waterwave.net.aio.define.AioServerDataDealer;\r\nimport waterwave.proxy.router.ProxyRouter;\r\nimport java.io.IOException;\r\nimport java.net.SocketAddress;\r\nimport java.nio.ByteBuffer;\r\nimport java.nio.channels.WritePendingException;\r\nimport java.util.LinkedList;\r\nimport shui.common.buffer.BufferTools;\r\nimport shui.common.log.Logger;\r\nimport shui.common.service.ThreadSharedService;\r\nimport shui.common.util.CommonUtil;\r\nimport waterwave.net.aio.AioClient;\r\nimport waterwave.net.aio.AioClientChannel;\r\nimport waterwave.net.aio.AioServerChannel;\r\nimport waterwave.net.aio.define.AioClientDataDealer;\r\n/*\r\n * Licensed to waterwave under one or more contributor\r\n *  \r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *  \r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *  \r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npackage waterwave.proxy.aio;\r\n\r\n\r\n\r\n/**\r\n * \r\n * @author vv\r\n * \r\n * \r\n *         server:in -> queue \r\n *         client:in -> queue\r\n * \r\n *\r\n */\r\npublic class ProxyAioDataDealer extends ThreadSharedService implements AioServerDataDealer, AioClientDataDealer {\r\n\r\n\tAioClientChannel cc;\r\n\tAioServerChannel sc;\r\n\r\n\tAioClient client;\r\n\tSocketAddress remote;\r\n\r\n\tprivate boolean clientIniting;\r\n\r\n\tpublic ProxyAioDataDealer() {\r\n\r\n\t}\r\n\t\r\n\tfinal static boolean debug = false;\r\n\t\r\n\r\n\tpublic AioClient getClient() {\r\n\t\treturn client;\r\n\t}\r\n\tpublic void setClient(AioClient client) {\r\n\t\tthis.client = client;\r\n\t}\r\n\r\n\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\t// TODO Auto-generated method stub\r\n\r\n\t}\r\n\t\r\n\r\n\r\n\t@Override\r\n\tpublic void serverOnConnect(AioServerChannel channel) {\r\n\t\tthis.sc = channel;\r\n\t\t\r\n\t\tclientIniting = true;\r\n\t\ttry {\r\n\t\t\tremote = ProxyRouter.getStaticRemote();\r\n\t\t\tclient.connect(remote, this);\r\n\t\t} catch (IOException e) {\r\n\t\t\tthis.clientOnError(null, e, null);\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void serverBeforeRead(AioServerChannel channel) {\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void serverOnData(AioServerChannel channel, ByteBuffer b, int bytes) {\r\n\t\t//log.log(1, \"serverOnData...\", b);\r\n\t\t\r\n\t\t//TODO\r\n\t\t//Logger.log(new String(BufferTools.getBuffer2Byte(b)));\r\n\t\t\r\n\t\t//init client\r\n\t\tif (cc == null) {\r\n\t\t\tif (clientIniting) {\r\n\t\t\t\tlog.log(9, \"serverOnData clientIniting long ...............\");\r\n\t\t\t}\r\n\r\n//\t\t\tclientIniting = true;\r\n//\t\t\ttry {\r\n//\t\t\t\tremote = ProxyAioRouter.getStaticRemote();\r\n//\t\t\t\tclient.connect(remote, this);\r\n//\t\t\t} catch (IOException e) {\r\n//\t\t\t\tthis.clientOnError(null, e, null);\r\n//\t\t\t\te.printStackTrace();\r\n//\t\t\t}\r\n\t\t\twaitingToIniting(b);\r\n\t\t\t\r\n\t\t} else {\r\n\t\t\t//normal\r\n\t\t\twriteToClient(b);\r\n\t\t\tchekcServerQueue();\r\n\t\t}\r\n\r\n\t}\r\n\t\r\n\r\n\t@Override\r\n\tpublic void serverAfterWrite(AioServerChannel channel, ByteBuffer buffer, int bytes) {\r\n\t\tchekcServerQueue();\r\n\t}\r\n\t\r\n\tprivate final LinkedList<ByteBuffer> cq = new LinkedList<>();\r\n\tprivate final LinkedList<ByteBuffer> sq = new LinkedList<>();\r\n\t\r\n\tprivate void waitingToIniting(ByteBuffer buffer) {\r\n\t\tsynchronized (cq) {\r\n\t\t\tcq.add(buffer);\r\n\t\t}\r\n\t}\r\n\r\n\r\n\r\n\tprivate final void writeToClient(ByteBuffer buffer) {\r\n\t\tsynchronized (cq) {\r\n\t\t\tif (cq.size() == 0) {\r\n\t\t\t\twriteToClient0(buffer);\r\n\t\t\t} else {\r\n\t\t\t\tcq.add(buffer);\r\n\t\t\t\twriteClientFromQueue();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate final void writeToServer(ByteBuffer buffer) {\r\n\t\tsynchronized (sq) {\r\n\t\t\tif (sq.size() == 0) {\r\n\t\t\t\twriteToServer0(buffer);\r\n\t\t\t} else {\r\n\t\t\t\tsq.add(buffer);\r\n\t\t\t\twriteServerFromQueue();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate final void writeToServer0(ByteBuffer buffer) {\r\n\t\ttry {\r\n\t\t\tbuffer.flip();\r\n\t\t\tsc.write(buffer);\r\n\t\t} catch (WritePendingException e) {\r\n\t\t\te.printStackTrace();\r\n\t\t\tbuffer.position(buffer.limit());\r\n\t\t\tsq.add(buffer);\r\n\t\t\twriteServerFromQueue();\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate final void writeToClient0(ByteBuffer buffer) {\r\n\t\ttry {\r\n\t\t\tbuffer.flip();\r\n\t\t\tcc.write(buffer);\r\n\t\t} catch (WritePendingException e) {\r\n\t\t\te.printStackTrace();\r\n\t\t\tbuffer.position(buffer.limit());\r\n\t\t\tcq.add(buffer);\r\n\t\t\twriteClientFromQueue();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * client writeQueue and merge Buffer;\r\n\t * \r\n\t */\r\n\tprivate final void writeClientFromQueue() {\r\n\t\t//log.log(1, \"cq\", cq, cq.size());\r\n\t\tByteBuffer b0 = cq.poll();\r\n\t\t\r\n\t\tfor (;;) {\r\n\t\t\tByteBuffer b1 = cq.peek();\r\n\t\t\tif (b1 == null) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tint r0 = b0.remaining();\r\n\t\t\tint s1 = b1.position();\r\n\t\t\tif (s1 > r0) {\r\n\t\t\t\tbreak;\r\n\t\t\t} else {\r\n\t\t\t\tif(b0 != b1) {\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\tb0.put(b1);\r\n\t\t\t\tcq.poll();\rNext line of code:\n", "input": "import waterwave.net.aio.define.AioServerDataDealer;\r\nimport waterwave.proxy.router.ProxyRouter;\r\nimport java.io.IOException;\r\nimport java.net.SocketAddress;\r\nimport java.nio.ByteBuffer;\r\nimport java.nio.channels.WritePendingException;\r\nimport java.util.LinkedList;\r\nimport shui.common.buffer.BufferTools;\r\nimport shui.common.log.Logger;\r\nimport shui.common.service.ThreadSharedService;\r\nimport shui.common.util.CommonUtil;\r\nimport waterwave.net.aio.AioClient;\r\nimport waterwave.net.aio.AioClientChannel;\r\nimport waterwave.net.aio.AioServerChannel;\r\nimport waterwave.net.aio.define.AioClientDataDealer;\r\n/*\r\n * Licensed to waterwave under one or more contributor\r\n *  \r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *  \r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *  \r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npackage waterwave.proxy.aio;\r\n\r\n\r\n\r\n/**\r\n * \r\n * @author vv\r\n * \r\n * \r\n *         server:in -> queue \r\n *         client:in -> queue\r\n * \r\n *\r\n */\r\npublic class ProxyAioDataDealer extends ThreadSharedService implements AioServerDataDealer, AioClientDataDealer {\r\n\r\n\tAioClientChannel cc;\r\n\tAioServerChannel sc;\r\n\r\n\tAioClient client;\r\n\tSocketAddress remote;\r\n\r\n\tprivate boolean clientIniting;\r\n\r\n\tpublic ProxyAioDataDealer() {\r\n\r\n\t}\r\n\t\r\n\tfinal static boolean debug = false;\r\n\t\r\n\r\n\tpublic AioClient getClient() {\r\n\t\treturn client;\r\n\t}\r\n\tpublic void setClient(AioClient client) {\r\n\t\tthis.client = client;\r\n\t}\r\n\r\n\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\t// TODO Auto-generated method stub\r\n\r\n\t}\r\n\t\r\n\r\n\r\n\t@Override\r\n\tpublic void serverOnConnect(AioServerChannel channel) {\r\n\t\tthis.sc = channel;\r\n\t\t\r\n\t\tclientIniting = true;\r\n\t\ttry {\r\n\t\t\tremote = ProxyRouter.getStaticRemote();\r\n\t\t\tclient.connect(remote, this);\r\n\t\t} catch (IOException e) {\r\n\t\t\tthis.clientOnError(null, e, null);\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void serverBeforeRead(AioServerChannel channel) {\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void serverOnData(AioServerChannel channel, ByteBuffer b, int bytes) {\r\n\t\t//log.log(1, \"serverOnData...\", b);\r\n\t\t\r\n\t\t//TODO\r\n\t\t//Logger.log(new String(BufferTools.getBuffer2Byte(b)));\r\n\t\t\r\n\t\t//init client\r\n\t\tif (cc == null) {\r\n\t\t\tif (clientIniting) {\r\n\t\t\t\tlog.log(9, \"serverOnData clientIniting long ...............\");\r\n\t\t\t}\r\n\r\n//\t\t\tclientIniting = true;\r\n//\t\t\ttry {\r\n//\t\t\t\tremote = ProxyAioRouter.getStaticRemote();\r\n//\t\t\t\tclient.connect(remote, this);\r\n//\t\t\t} catch (IOException e) {\r\n//\t\t\t\tthis.clientOnError(null, e, null);\r\n//\t\t\t\te.printStackTrace();\r\n//\t\t\t}\r\n\t\t\twaitingToIniting(b);\r\n\t\t\t\r\n\t\t} else {\r\n\t\t\t//normal\r\n\t\t\twriteToClient(b);\r\n\t\t\tchekcServerQueue();\r\n\t\t}\r\n\r\n\t}\r\n\t\r\n\r\n\t@Override\r\n\tpublic void serverAfterWrite(AioServerChannel channel, ByteBuffer buffer, int bytes) {\r\n\t\tchekcServerQueue();\r\n\t}\r\n\t\r\n\tprivate final LinkedList<ByteBuffer> cq = new LinkedList<>();\r\n\tprivate final LinkedList<ByteBuffer> sq = new LinkedList<>();\r\n\t\r\n\tprivate void waitingToIniting(ByteBuffer buffer) {\r\n\t\tsynchronized (cq) {\r\n\t\t\tcq.add(buffer);\r\n\t\t}\r\n\t}\r\n\r\n\r\n\r\n\tprivate final void writeToClient(ByteBuffer buffer) {\r\n\t\tsynchronized (cq) {\r\n\t\t\tif (cq.size() == 0) {\r\n\t\t\t\twriteToClient0(buffer);\r\n\t\t\t} else {\r\n\t\t\t\tcq.add(buffer);\r\n\t\t\t\twriteClientFromQueue();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate final void writeToServer(ByteBuffer buffer) {\r\n\t\tsynchronized (sq) {\r\n\t\t\tif (sq.size() == 0) {\r\n\t\t\t\twriteToServer0(buffer);\r\n\t\t\t} else {\r\n\t\t\t\tsq.add(buffer);\r\n\t\t\t\twriteServerFromQueue();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate final void writeToServer0(ByteBuffer buffer) {\r\n\t\ttry {\r\n\t\t\tbuffer.flip();\r\n\t\t\tsc.write(buffer);\r\n\t\t} catch (WritePendingException e) {\r\n\t\t\te.printStackTrace();\r\n\t\t\tbuffer.position(buffer.limit());\r\n\t\t\tsq.add(buffer);\r\n\t\t\twriteServerFromQueue();\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate final void writeToClient0(ByteBuffer buffer) {\r\n\t\ttry {\r\n\t\t\tbuffer.flip();\r\n\t\t\tcc.write(buffer);\r\n\t\t} catch (WritePendingException e) {\r\n\t\t\te.printStackTrace();\r\n\t\t\tbuffer.position(buffer.limit());\r\n\t\t\tcq.add(buffer);\r\n\t\t\twriteClientFromQueue();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * client writeQueue and merge Buffer;\r\n\t * \r\n\t */\r\n\tprivate final void writeClientFromQueue() {\r\n\t\t//log.log(1, \"cq\", cq, cq.size());\r\n\t\tByteBuffer b0 = cq.poll();\r\n\t\t\r\n\t\tfor (;;) {\r\n\t\t\tByteBuffer b1 = cq.peek();\r\n\t\t\tif (b1 == null) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tint r0 = b0.remaining();\r\n\t\t\tint s1 = b1.position();\r\n\t\t\tif (s1 > r0) {\r\n\t\t\t\tbreak;\r\n\t\t\t} else {\r\n\t\t\t\tif(b0 != b1) {\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\tb0.put(b1);\r\n\t\t\t\tcq.poll();\r", "context": "src/main/java/waterwave/proxy/router/ProxyRouter.java\npublic class ProxyRouter {\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\t// TODO Auto-generated method stub\r\n\r\n\t}\r\n\r\n\tpublic static SocketAddress staticRemote;\r\n\tpublic static InetAddress staticRemoteIp;\r\n\tpublic static int staticRemotePort;\r\n\tpublic static SocketAddress getStaticRemote() {\r\n\t\t// TODO Auto-generated method stub\r\n\t\treturn staticRemote;\r\n\t}\r\n\r\n}\r\nsrc/main/java/shui/common/util/CommonUtil.java\npublic class CommonUtil {\r\n\tpublic static String getLocalIp() {\r\n\t\tInetAddress addr;\r\n\t\ttry {\r\n\t\t\taddr = InetAddress.getLocalHost();\r\n\t\t\tString ip = addr.getHostAddress().toString();\r\n\t\t\treturn ip;\r\n\t\t} catch (UnknownHostException e) {\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t\treturn null;\r\n\r\n\t}\r\n\t\r\n\tpublic final static String getStringFromException(Throwable e) {\r\n\r\n\t\tStringWriter sw = new StringWriter();\r\n\t\tPrintWriter ps = new PrintWriter(sw);\r\n\r\n\t\te.printStackTrace(ps);\r\n\r\n\t\treturn sw.toString();\r\n\t}\r\n}\r\nsrc/main/java/shui/common/service/ThreadSharedService.java\npublic class ThreadSharedService {\r\n\tprotected final Logger log = new SimpleLogger(true);\r\n\t\r\n\tpublic static void main(String[] args) {\r\n\r\n\t}\r\n\r\n}\r\nsrc/main/java/waterwave/net/aio/AioClient.java\npublic final class AioClient extends AioService implements Runnable {\r\n\r\n\t// private final AsynchronousSocketChannel listener;\r\n\tprivate final AsynchronousChannelGroup channelGroup;\r\n\tprivate final AioDataDealerFactory aioDataDealerFactory;\r\n\t\r\n\tprivate final Map<Integer, AioServerChannel> connections = new ConcurrentHashMap<Integer, AioServerChannel>();\r\n\t\r\n\r\n\tpublic AioClient(ExecutorService channelWorkers, AioDataDealerFactory aioDataDealerFactory) throws IOException {\r\n\t\t// ExecutorService channelWorkers = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors(), Executors.defaultThreadFactory());\r\n\t\tchannelGroup = AsynchronousChannelGroup.withThreadPool(channelWorkers);\r\n\t\tthis.aioDataDealerFactory = aioDataDealerFactory;\r\n\t}\r\n\r\n\tclass AcceptHandler implements CompletionHandler<Void, Void> {\r\n\t\tprivate final AsynchronousSocketChannel listener;\r\n\t\tprivate final AioClientDataDealer aioClientDataDealer;\r\n\r\n\t\tpublic AcceptHandler(AsynchronousSocketChannel listener, AioClientDataDealer aioClientDataDealer) {\r\n\t\t\tsuper();\r\n\t\t\tthis.listener = listener;\r\n\t\t\tthis.aioClientDataDealer = aioClientDataDealer;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic void completed(Void result, Void attachment) {\r\n\t\t\t//log.log(1, \"Client AcceptHandler connected \");\r\n\t\t\thandleNewConnection(listener, aioClientDataDealer);\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic void failed(Throwable exc, Void attachment) {\r\n\t\t\t//log.log(1, \"Client AcceptHandler failed result: \" + exc);\r\n\t\t}\r\n\r\n\t}\r\n\t\r\n\tpublic AsynchronousSocketChannel connect(SocketAddress remote) throws IOException {\r\n\t\treturn connect(remote, null);\r\n\t}\r\n\tpublic AsynchronousSocketChannel connect(SocketAddress remote, AioClientDataDealer aioClientDataDealer) throws IOException {\r\n\t\tAsynchronousSocketChannel listener = createListener(channelGroup);\r\n\t\t//log.log(1, \"client start connect\");\r\n\r\n\t\tAcceptHandler acceptHandler = new AcceptHandler(listener, aioClientDataDealer);\r\n\r\n\t\tlistener.connect(remote, null, acceptHandler);\r\n\t\treturn listener;\r\n\t}\r\n\r\n\tprotected void handleNewConnection(AsynchronousSocketChannel channel, AioClientDataDealer aioClientDataDealer) {\r\n\t\tif (!channel.isOpen()) {\r\n\t\t\t//log.log(1, \"handleNewConnection closed.. \");\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\tAioClientDataDealer dealer = null;\r\n\t\tif (aioClientDataDealer != null) {\r\n\t\t\tdealer = aioClientDataDealer;\r\n\t\t} else {\r\n\t\t\taioDataDealerFactory.getAioClientDataDealer();\r\n\t\t}\r\n\r\n\t\tint channelId = getChannelId();\r\n\t\tAioClientChannel aioChannel = new AioClientChannel(channelId, channel, dealer, this);\r\n\t\t\r\n\t\t// connections.add(aioChannel);\r\n\t\taioChannel.run(null);\r\n\t\t\r\n\t\tdealer.clientOnConnect(aioChannel);\r\n\r\n\t\t// String w = \"GET / HTTP/1.1 \\n\\n\";\r\n\t\t// ByteBuffer buffer = ByteBuffer.wrap(w.getBytes());\r\n\t\t// System.out.println(\"set write \");\r\n\t\t// channel.write(buffer, buffer, new CompletionHandler<Integer, ByteBuffer>() {\r\n\t\t// @Override\r\n\t\t// public void completed(Integer result, ByteBuffer buffer) {\r\n\t\t// if (buffer.hasRemaining()) {\r\n\t\t// System.out.println(\"write... \");\r\n\t\t// channel.write(buffer, buffer, this);\r\n\t\t// } else {\r\n\t\t// // Go back and check if there is new data to write\r\n\t\t// // writeFromQueue();\r\n\t\t// System.out.println(\"write complete \" + result);\r\n\t\t// }\r\n\t\t// }\r\n\t\t//\r\n\t\t// @Override\r\n\t\t// public void failed(Throwable exc, ByteBuffer attachment) {\r\n\t\t// }\r\n\t\t// });\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * \r\n\t * \r\n\t * @param channelGroup\r\n\t * @return\r\n\t * @throws IOException\r\n\t * \r\n\t * \r\n\t *             SO_SNDBUF The size of the socket send buffer .\r\n\t *             SO_RCVBUF The size of the socket receive buffer. \r\n\t *             SO_KEEPALIVE Keep connection alive. \r\n\t *             SO_REUSEADDR Re-use address .\r\n\t *             TCP_NODELAY Disable the Nagle algorithm.\r\n\t * \r\n\t * \r\n\t */\r\n\tprivate AsynchronousSocketChannel createListener(AsynchronousChannelGroup channelGroup) throws IOException {\r\n\t\tfinal AsynchronousSocketChannel listener = AsynchronousSocketChannel.open(channelGroup);\r\n\t\t//TODO\r\n\t\t//listener.setOption(StandardSocketOptions.TCP_NODELAY, true);\r\n\t\tlistener.setOption(StandardSocketOptions.SO_REUSEADDR, true);\r\n\t\tlistener.setOption(StandardSocketOptions.SO_RCVBUF, 16 * 1024);\r\n\t\tlistener.setOption(StandardSocketOptions.SO_SNDBUF, 16 * 1024);\r\n\t\treturn listener;\r\n\t}\r\n\r\n\t//for test\r\n\t@Override\r\n\tpublic void run() {\r\n\t\tSystem.out.println(Thread.currentThread().getName() + \"---run\");\r\n\r\n\t\tInetSocketAddress r = new InetSocketAddress(\"10.213.33.176\", 11200);\r\n\t\ttry {\r\n\t\t\tAsynchronousSocketChannel channel = connect(r);\r\n\t\t\tSystem.out.println(channel);\r\n\t\t} catch (IOException e) {\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * \r\n\t */\r\n\tprivate AtomicInteger channelId = new AtomicInteger();\r\n\tprivate int getChannelId() {\r\n\t\treturn channelId.incrementAndGet();\r\n\t}\r\n\r\n\tpublic void removeAioChannel(AioClientChannel client) {\r\n       connections.remove(client.getChannelId());\r\n\t}\r\n\t\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\ttry {\r\n\t\t\tint threadCap = 4;\r\n\t\t\tExecutorService channelWorkers = Executors.newFixedThreadPool(threadCap, Executors.defaultThreadFactory());\r\n\t\t\tAioClient c = new AioClient(channelWorkers, null);\r\n\t\t\tc.run();\r\n\r\n\t\t\tThread.sleep(100000);\r\n\r\n\t\t} catch (Exception e) {\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\nsrc/main/java/waterwave/net/aio/AioClientChannel.java\npublic final class AioClientChannel extends AioChannel{\r\n\t\r\n\tprivate final AsynchronousSocketChannel channel;\r\n\tprivate final AioClientDataDealer dealer;\r\n\t\r\n\tprivate final AioClient aioClient;\r\n\tprivate final int channelId;\r\n\t\r\n\t\r\n\t\r\n\r\n\tpublic AsynchronousSocketChannel getChannel() {\r\n\t\treturn channel;\r\n\t}\r\n\r\n\tpublic int getChannelId() {\r\n\t\treturn channelId;\r\n\t}\t\r\n\r\n\tpublic AioClientChannel(int channelId, AsynchronousSocketChannel channel, AioClientDataDealer dealer, AioClient aioClient) {\r\n\t\tthis.channelId = channelId;\r\n\t\tthis.channel = channel;\r\n\t\tthis.dealer = dealer;\r\n\t\tthis.aioClient = aioClient;\r\n\t}\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\t// TODO Auto-generated method stub\r\n\r\n\t}\r\n\r\n\tpublic void run(ReadHandler reader) {\r\n\t\tdealer.clientBeforeRead(this);\r\n\t\tif(reader == null){\r\n\t\t\t//new\r\n\t\t\treader = new ReadHandler(this);\r\n\t\t}\r\n\t\tread(reader);\r\n\t\t\r\n\t}\r\n\t\r\n\t/**\r\n     * Runs a cycle of doing a beforeRead action and then enqueuing a new\r\n     * read on the client. Handles closed channels and errors while reading.\r\n     * If the client is still connected a new round of actions are called.\r\n     */\r\n\tclass ReadHandler implements CompletionHandler<Integer, ByteBuffer>{\r\n\t\tAioClientChannel clientChannel;\r\n\t\t\r\n        public ReadHandler(AioClientChannel clientChannel) {\r\n\t\t\tsuper();\r\n\t\t\tthis.clientChannel = clientChannel;\r\n\t\t}\r\n\r\n        @Override\r\n\t\tpublic void completed(Integer result, ByteBuffer buffer) {\r\n\t\t\t// if result is negative or zero the connection has been closed or something gone wrong\r\n\t\t\t//log.log(1, \"client ReadHandler read success: \");\r\n\t\t\tif (result < 1) {\r\n\t\t\t\tclientChannel.close();\r\n\t\t\t\tdealer.clientOnClose(clientChannel);\r\n\t\t\t\t\r\n\t\t\t\t//log.log(1, \"result < 1 ReadHandler Closing connection to \" + channel);\r\n\t\t\t} else {\r\n//\t\t\t\tSystem.out.println(\"result: \" + result);\r\n//\t\t\t\t// callback.onData(client, buffer, result);\r\n//\t\t\t\tbuffer.flip();\r\n//\t\t\t\tString name;\r\n//\t\t\t\tname = new String(buffer.array(), 0, result);\r\n//\t\t\t\tSystem.out.println(\"data: \" + name);\r\n//\t\t\t\t// enqueue next round of actions\r\n//\t\t\t\t// client.run();\r\n\t\t\t\t\r\n\t\t\t\tdealer.clientOnData(clientChannel, buffer, result);\r\n                // enqueue next round of actions\r\n\t\t\t\tclientChannel.run(this);\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic void failed(Throwable e, ByteBuffer buffer) {\r\n\t\t\tlog.log(9, \"client ReadHandler read fail: \" + e);\r\n\t\t\t\r\n\t\t\tclientChannel.close();\r\n\t\t\tdealer.clientOnError(clientChannel, e, buffer);\r\n\t\t}\r\n\t\t\r\n//\t\tpublic void onData(AioServerChannel channel, ByteBuffer buffer, int bytes) {\r\n//\t        buffer.flip();\r\n//\t        // Just append the message on the buffer\r\n//\t        //AioServerChannel.appendMessage(new String(buffer.array(), 0, bytes));\r\n//\t    }\r\n\t\t\r\n\t}\r\n\t\r\n\tclass WriteHandler implements CompletionHandler<Integer, ByteBuffer>{\r\n\t\tAioClientChannel clientChannel;\r\n\t\t\r\n        public WriteHandler(AioClientChannel clientChannel) {\r\n\t\t\tsuper();\r\n\t\t\tthis.clientChannel = clientChannel;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic void completed(Integer result, ByteBuffer buffer) {\r\n\t\t\t// if result is negative or zero the connection has been closed or something gone wrong\r\n\t\t\t//log.log(1, \"client WriteHandler write success: \");\r\n\t\t\tif (buffer.hasRemaining()) {\r\n\t\t\t\t//log.log(1, \"client WriteHandler write...  hasRemaining \");\r\n\t\t\t\tchannel.write(buffer, buffer, this);\r\n\t\t\t} else {\r\n\t\t\t\t// Go back and check if there is new data to write\r\n\t\t\t\t// writeFromQueue();\r\n\t\t\t\t//log.log(1, \"client write complete \" + result);\r\n\r\n\t\t\t}\r\n\t\t\tdealer.clientAfterWrite(clientChannel, buffer, result);\r\n\t\t\t\r\n\t\t\tBufferTools.returnBuffer(buffer);\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic void failed(Throwable e, ByteBuffer buffer) {\r\n\t\t\tlog.log(9, \"client WriteHandler write fail: \" + e);\r\n\t\t\tclientChannel.close();\r\n\t\t}\r\n\t\t\r\n//\t\tpublic void onData(AioServerChannel channel, ByteBuffer buffer, int bytes) {\r\n//\t        buffer.flip();\r\n//\t        // Just append the message on the buffer\r\n//\t        //AioServerChannel.appendMessage(new String(buffer.array(), 0, bytes));\r\n//\t    }\r\n\t\t\r\n\t}\r\n\t\r\n    /**\r\n     * Enqueue a read\r\n     * @param completionHandler callback on completed read\r\n     */\r\n    public final void read(CompletionHandler<Integer, ? super ByteBuffer> completionHandler) {\r\n    \t//log.log(1, \"Cliet: start client read \");\r\n    \t\r\n        ByteBuffer input = BufferTools.getBuffer();\r\n        if (!channel.isOpen()) {\r\n            return;\r\n        }\r\n        channel.read(input, input, completionHandler);\r\n    }\r\n    \r\n    \r\n    private CompletionHandler<Integer, ? super ByteBuffer> writerHandler = null;\r\n    public final void write(final ByteBuffer input) {\r\n    \tif(this.writerHandler == null) {\r\n    \t\twriterHandler = new WriteHandler(this);\r\n    \t}\r\n    \twrite(input, writerHandler);\r\n    }\r\n    \r\n    /**\r\n     * Enqueue a read\r\n     * @param completionHandler callback on completed read\r\n     */\r\n    protected final void write(ByteBuffer b ,CompletionHandler<Integer, ? super ByteBuffer> completionHandler) {\r\n    \t//log.log(1, \"start client write \");\r\n    \t\r\n        if (!channel.isOpen()) {\r\n            return;\r\n        }\r\n        channel.write(b, b, completionHandler);\r\n    }\r\n    \r\n\r\n\tpublic void close() {\r\n        try {\r\n            channel.close();\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n        aioClient.removeAioChannel(this);\r\n\t\t\r\n\t\t\r\n\t}\r\n\r\n}\r\nsrc/main/java/waterwave/net/aio/AioServerChannel.java\npublic final class AioServerChannel extends AioChannel{\r\n\t\r\n\tprivate final AsynchronousSocketChannel channel;\r\n\tprivate final AioServerDataDealer dealer;\r\n\tprivate final AioServer aioServer;\r\n\tprivate final int channelId;\r\n    //private final Queue<ByteBuffer> queue = new LinkedList<ByteBuffer>();\r\n\tprivate final Queue<ByteBuffer> queue = null;\r\n    \r\n    private boolean writing = false;\r\n\t\r\n    \r\n\r\n\tpublic int getChannelId() {\r\n\t\treturn channelId;\r\n\t}\r\n\r\n\r\n\tpublic AioServerChannel(int channelId, AsynchronousSocketChannel channel, AioServerDataDealer dealer, AioServer aioServer) {\r\n\t\tdealer.serverOnConnect(this);\r\n\t\tthis.channel = channel;\r\n\t\tthis.dealer = dealer;\r\n\t\tthis.aioServer = aioServer;\r\n\t\tthis.channelId = channelId;\r\n\t}\r\n\r\n\r\n\tpublic void run(ReadHandler reader) {\r\n\t\tdealer.serverBeforeRead(this);\r\n\t\tif (reader == null) {\r\n\t\t\treader = new ReadHandler(this);\r\n\t\t}\r\n\t\tread(reader);\r\n\r\n\t}\r\n\t\r\n    /**\r\n     * Runs a cycle of doing a beforeRead action and then enqueuing a new\r\n     * read on the client. Handles closed channels and errors while reading.\r\n     * If the client is still connected a new round of actions are called.\r\n     */\r\n\tclass ReadHandler implements CompletionHandler<Integer, ByteBuffer>{\r\n\t\tAioServerChannel serverChannel;\r\n\t\t\r\n        public ReadHandler(AioServerChannel serverChannel) {\r\n\t\t\tsuper();\r\n\t\t\tthis.serverChannel = serverChannel;\r\n\t\t}\r\n\r\n\t\t@Override\r\n        public void completed(Integer result, ByteBuffer buffer) {\r\n            // if result is negative or zero the connection has been closed or something gone wrong\r\n            if (result < 1) {\r\n            \t//log.log(1, \"server:ReadHandler result < 1 Closing connection to \" + serverChannel);\r\n            \t\r\n            \tserverChannel.close();\r\n            \tdealer.serverOnClose(serverChannel);\r\n            \t\r\n            } else {\r\n            \tdealer.serverOnData(serverChannel, buffer, result);\r\n                // enqueue next round of actions\r\n                serverChannel.run(this);\r\n            }\r\n        }\r\n\r\n\t\t@Override\r\n\t\tpublic void failed(Throwable exc, ByteBuffer attachment) {\r\n\t\t\t// TODO Auto-generated method stub\r\n\t\t\tserverChannel.close();\r\n\t\t\t\r\n\t\t\tdealer.serverOnError(serverChannel, exc, attachment);\r\n\t\t}\r\n\t\t\r\n//\t\tpublic void onData(AioServerChannel channel, ByteBuffer buffer, int bytes) {\r\n//\t        buffer.flip();\r\n//\t        // Just append the message on the buffer\r\n//\t        //AioServerChannel.appendMessage(new String(buffer.array(), 0, bytes));\r\n//\t    }\r\n\t\t\r\n\t}\r\n\t\r\n    /**\r\n     * Enqueue a read\r\n     * @param completionHandler callback on completed read\r\n     */\r\n    public final void read(CompletionHandler<Integer, ? super ByteBuffer> completionHandler) {\r\n        ByteBuffer input = BufferTools.getBuffer();\r\n        if (!channel.isOpen()) {\r\n            return;\r\n        }\r\n        channel.read(input, input, completionHandler);\r\n    }\r\n    \r\n\r\n    \r\n\tclass WriteHandler implements CompletionHandler<Integer, ByteBuffer>{\r\n\t\tAioServerChannel serverChannel;\r\n\t\t\r\n        public WriteHandler(AioServerChannel serverChannel) {\r\n\t\t\tsuper();\r\n\t\t\tthis.serverChannel = serverChannel;\r\n\t\t}\r\n\r\n        @Override\r\n\t\tpublic void completed(Integer result, ByteBuffer buffer) {\r\n\t\t\t// if result is negative or zero the connection has been closed or something gone wrong\r\n\t\t\t//System.out.println(\"read success: \");\r\n\t\t\tif (buffer.hasRemaining()) {\r\n\t\t\t\t//log.log(1, \"server write... \");\r\n\t\t\t\tchannel.write(buffer, buffer, this);\r\n\t\t\t} else {\r\n\t\t\t\t// Go back and check if there is new data to write\r\n\t\t\t\t// writeFromQueue();\r\n\t\t\t\t//log.log(1, \"server write complete \" + result);\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\tdealer.serverAfterWrite(serverChannel, buffer, result);\r\n\t\t\tBufferTools.returnBuffer(buffer);\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic void failed(Throwable exc, ByteBuffer buffer) {\r\n\t\t\tlog.log(9, \"server WriteHandler write fail: \" + exc);\r\n\t\t\tserverChannel.close();\r\n\t\t}\r\n\t\t\r\n//\t\tpublic void onData(AioServerChannel channel, ByteBuffer buffer, int bytes) {\r\n//\t        buffer.flip();\r\n//\t        // Just append the message on the buffer\r\n//\t        //AioServerChannel.appendMessage(new String(buffer.array(), 0, bytes));\r\n//\t    }\r\n\t\t\r\n\t}\r\n    \r\n    \r\n\r\n    \r\n    private CompletionHandler<Integer, ? super ByteBuffer> writerHandler = null;\r\n    public final void write(final ByteBuffer input) {\r\n    \tif(this.writerHandler == null) {\r\n    \t\twriterHandler = new WriteHandler(this);\r\n    \t}\r\n    \twrite(input, writerHandler);\r\n    }\r\n    \r\n    /**\r\n     * Enqueue a read\r\n     * @param completionHandler callback on completed read\r\n     */\r\n    protected final void write(ByteBuffer b ,CompletionHandler<Integer, ? super ByteBuffer> completionHandler) {\r\n    \t//log.log(1, \"start server write \");\r\n    \t\r\n        if (!channel.isOpen()) {\r\n            return;\r\n        }\r\n        channel.write(b, b, completionHandler);\r\n    }\r\n    \r\n\r\n\r\n\t\r\n\t/**\r\n     * Closes the channel\r\n     */\r\n    public void close() {\r\n        try {\r\n            channel.close();\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n        aioServer.removeAioChannel(this);\r\n    }\r\n\r\n\r\n    \r\n    /**\r\n     * Enqueues a write of the buffer to the channel.\r\n     * The call is asynchronous so the buffer is not safe to modify after\r\n     * passing the buffer here.\r\n     *\r\n     * @param buffer the buffer to send to the channel\r\n     */\r\n    @Deprecated\r\n    public void writeOld(final ByteBuffer buffer) {\r\n        boolean threadShouldWrite = false;\r\n\r\n        synchronized(queue) {\r\n            queue.add(buffer);\r\n            // Currently no thread writing, make this thread dispatch a write\r\n            if (!writing) {\r\n                writing = true;\r\n                threadShouldWrite = true;\r\n            }\r\n        }\r\n\r\n        if (threadShouldWrite) {\r\n        \twriteFromQueueOld();\r\n        }\r\n    }\r\n    \r\n    @Deprecated\r\n    private void writeFromQueueOld() {\r\n        ByteBuffer buffer;\r\n\r\n        synchronized (queue) {\r\n            buffer = queue.poll();\r\n            if (buffer == null) {\r\n                writing = false;\r\n            }\r\n        }\r\n\r\n        // No new data in buffer to write\r\n        if (writing) {\r\n        \twriteBufferOld(buffer);\r\n        }\r\n    }\r\n    \r\n    @Deprecated\r\n    private void writeBufferOld(ByteBuffer buffer) {\r\n        channel.write(buffer, buffer, new CompletionHandler<Integer, ByteBuffer>() {\r\n            @Override\r\n            public void completed(Integer result, ByteBuffer buffer) {\r\n                if (buffer.hasRemaining()) {\r\n                    channel.write(buffer, buffer, this);\r\n                } else {\r\n                    // Go back and check if there is new data to write\r\n                \twriteFromQueueOld();\r\n                }\r\n            }\r\n\r\n            @Override\r\n            public void failed(Throwable exc, ByteBuffer attachment) {\r\n            }\r\n        });\r\n    }\r\n    \r\n    \r\n\r\n    /**\r\n     * Sends a message\r\n     * @param string the message\r\n     */\r\n    @Deprecated\r\n    public void writeStringMessageOld(String string) {\r\n    \twriteOld(ByteBuffer.wrap(string.getBytes()));\r\n    }\r\n\r\n    /**\r\n     * Send a message from a specific client\r\n     * @param client the message is sent from\r\n     * @param message to send\r\n     */\r\n    @Deprecated\r\n    public void writeMessageFromOld(AioServerChannel client, String message) {\r\n        if (dealer.serverAcceptsMessages()) {\r\n            //writeStringMessage(client.getUserName() + \": \" + message);\r\n        }\r\n    }\r\n    \r\n\r\n\t\r\n\r\n}\r\nsrc/main/java/waterwave/net/aio/define/AioServerDataDealer.java\npublic interface AioServerDataDealer {\r\n\t\r\n\tvoid serverOnConnect(AioServerChannel channel);\r\n    void serverBeforeRead(AioServerChannel channel);\r\n    void serverOnData(AioServerChannel channel, ByteBuffer buffer, int bytes);\r\n    void serverAfterWrite(AioServerChannel channel, ByteBuffer buffer, int bytes);\r\n    void serverOnError(AioServerChannel channel,Throwable exc, ByteBuffer attachment);\r\n    void serverOnClose(AioServerChannel channel);\r\n    boolean serverAcceptsMessages();\r\n    \r\n\r\n}\r\nsrc/main/java/shui/common/buffer/BufferTools.java\npublic class BufferTools {\r\n\r\n\tprivate final static BufferPoolNIO bp = new BufferPoolNIO(2 * 1024, 32 * 1024);\r\n\t\r\n\tpublic final static ByteBuffer getBuffer() {\r\n\t\t//ByteBuffer input = ByteBuffer.allocate(16 * 1024);\r\n\t\tByteBuffer input = bp.allocate();\r\n\t\treturn input;\r\n\t}\r\n\r\n\tpublic final static void returnBuffer(ByteBuffer buffer) {\r\n\t\tbp.recycle(buffer);\r\n\t\t\r\n\t}\r\n\tpublic final static byte[] getBuffer2Byte(ByteBuffer b) {\r\n\t\tint p = b.position();\r\n\t\tbyte[] r = new byte[p];\r\n\t\tif (b.position() != 0) {\r\n\t\t\tb.flip();\r\n\t\t}\r\n\t\tb.get(r, 0, p);\r\n\r\n\t\treturn r;\r\n\t}\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\t// TODO Auto-generated method stub\r\n\r\n\t}\r\n\r\n\r\n}\r\nsrc/main/java/waterwave/net/aio/define/AioClientDataDealer.java\npublic interface AioClientDataDealer {\r\n\r\n    \r\n\tvoid clientBeforeRead(AioClientChannel channel);\r\n\tvoid clientOnConnect(AioClientChannel channel);\r\n\tvoid clientOnData(AioClientChannel channel, ByteBuffer buffer, int result);\r\n\tvoid clientAfterWrite(AioClientChannel channel, ByteBuffer buffer, int bytes);\r\n\tvoid clientOnError(AioClientChannel channel,Throwable exc, ByteBuffer attachment);\r\n    void clientOnClose(AioClientChannel channel);\r\n\tboolean clientAcceptsMessages();\r\n}\r\nsrc/main/java/shui/common/log/Logger.java\npublic abstract class Logger {\r\n\r\n\tpublic String threadInfo = null;\r\n\tpublic int level;\r\n\r\n\tprotected boolean printTime = true;\r\n\tprotected boolean printThreadInfo = true;\r\n\r\n\tpublic Logger() {\r\n\t}\r\n\r\n\tpublic Logger(boolean printTime) {\r\n\t\tthis();\r\n\t\tthis.printTime = printTime;\r\n\t}\r\n\r\n\t\r\n\tpublic abstract void log(int level, Object o) ;\r\n\tpublic abstract void log(int level, Object... os) ;\r\n\tpublic abstract PrintWriter getErrorWriter();\r\n\r\n\r\n\tpublic final static void log(byte[] bs) {\r\n\t\tfor (byte b : bs) {\r\n\t\t\tlog1(b);\r\n\t\t\tlog1(\"\\t\");\r\n\t\t}\r\n\t\tlog(\"\\t\");\r\n\t}\r\n\t\r\n\t\r\n\tpublic final static void log1(Object o) {\r\n\t\tSystem.out.print(o);\r\n\t}\r\n\t\r\n\tpublic final static void log(Object o) {\r\n\t\tSystem.out.println(o);\r\n\t}\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\t// TODO Auto-generated method stub\r\n\r\n\t}\r\n\r\n}\r\n", "answers": ["\t\t\t\tBufferTools.returnBuffer(b1);\r"], "length": 2646, "dataset": "repobench-p_e", "language": "java", "all_classes": null, "_id": "2f63d9a3d25c12812b10eb407a92d3744aaa94835463eb5b", "pred": "```java\n```\nPlease complete the code. The code is incomplete and there are many methods that are not implemented. The code is also not compiling due to missing imports and classes. Please provide the complete code. \n\nAlso, please note that the code is quite complex and it seems like it's a part of a"}
{"prompt": "Please complete the code given below. \nGUI/Widgets/SketchViewWidget.py\nclass SketchViewWidget(QWidget):\n\tdef __init__(self, parent, sketch, document):\n\t\tQWidget.__init__(self, parent)\n\t\tself._doc = document\n\t\tself._sketch = sketch\n\t\tself.setMinimumHeight(250)\n\t\tself.setMinimumWidth(250)\n\t\tself.setMouseTracking(True)\n\t\tself._show_areas = False\n\t\tself._areas_selectable = False\n\t\tself._edges_selectable = False\n\t\tself._keypoints_selectable = False\n\t\tself._change_listener = None\n\t\tself._selected_areas = []\n\t\tself._selected_edges = []\n\t\tself._selected_kps = []\n\t\tself._area_hover = None\n\t\tself._edge_hover = None\n\t\tself._kp_hover = None\n\t\tself._mouse_position = None\n\n\t@property\n\tdef selected_kps(self):\n\t    return self._selected_kps\n\n\t@selected_kps.setter\n\tdef selected_kps(self, value):\n\t\tself._selected_kps = value\n\t\tself.update()\n\n\tdef mouseMoveEvent(self, q_mouse_event):\n\t\tposition = q_mouse_event.pos()\n\t\tif self._mouse_position is not None:\n\t\t\tmouse_move_x = self._mouse_position.x() - position.x()\n\t\t\tmouse_move_y = self._mouse_position.y() - position.y()\n\t\telse:\n\t\t\tmouse_move_x = 0\n\t\t\tmouse_move_y = 0\n\t\tself._mouse_position = position\n\t\tif self._sketch is None:\n\t\t\treturn\n\t\tupdate_view = False\n\t\tif self._area_hover is not None or self._edge_hover is not None:\n\t\t\tupdate_view = True\n\t\tself._area_hover = None\n\t\tself._edge_hover = None\n\t\twidth = self.width() / 2\n\t\theight = self.height() / 2\n\t\tlimits = self._sketch.get_limits()\n\t\tsketch_width = limits[2] - limits[0]\n\t\tsketch_height = limits[3] - limits[1]\n\t\tscale_x = self.width() / sketch_width\n\t\tscale_y = self.height() / sketch_height\n\t\tscale = min(scale_x, scale_y) * 0.9\n\t\toffset = Vertex(-limits[0] - sketch_width / 2, -limits[1] - sketch_height / 2)\n\t\tx = (self._mouse_position.x() - width) / scale - offset.x\n\t\ty = -((self._mouse_position.y() - height) / scale + offset.y)\n\n\n\t\tif self._keypoints_selectable:\n\t\t\tfor key_point in self._sketch.get_keypoints():\n\t\t\t\tx1 = key_point.x\n\t\t\t\ty1 = key_point.y\n\t\t\t\tif abs(x1 - x) < 5 / scale and abs(y1 - y) < 5 / scale:\n\t\t\t\t\tself._kp_hover = key_point\n\t\t\t\t\tupdate_view = True\n\t\t\t\t\tbreak\n\t\tif self._edges_selectable:\n\t\t\tsmallest_dist = 10e10\n\t\t\tclosest_edge = None\n\t\t\tfor edge in self._sketch.get_edges():\n\t\t\t\tdist = edge.distance(Vertex(x, y, 0))\n\t\t\t\tif dist < smallest_dist:\n\t\t\t\t\tsmallest_dist = dist\n\t\t\t\t\tclosest_edge = edge\n\t\t\tif smallest_dist * scale < 10:\n\t\t\t\tself._edge_hover = closest_edge\n\t\t\t\tupdate_view = True\n\t\tif self._areas_selectable and self._edge_hover is None:\n\t\t\tfor area in self._sketch.get_areas():\n\t\t\t\tif area.inside(Vertex(x, y, 0)):\n\t\t\t\t\tself._area_hover = area\n\t\t\t\t\tupdate_view = True\n\t\t\t\t\tbreak\n\t\tif update_view:\n\t\t\tself.update()\n\n\tdef mousePressEvent(self, q_mouse_event):\n\t\tself.setFocus()\n\t\tposition = q_mouse_event.pos()\n\t\tif q_mouse_event.button() == 4:\n\t\t\treturn\n\t\tif q_mouse_event.button() == 1:\n\t\t\tpass\n\n\t\tif self._kp_hover is not None and self._keypoints_selectable:\n\t\t\tself._selected_kps.clear()\n\t\t\tself._selected_kps.append(self._kp_hover)\n\t\t\tif self._change_listener is not None:\n\t\t\t\tself._change_listener.on_kp_selected(self._kp_hover)\n\t\t\tself.update()\n\n\t\tif self._edge_hover is not None and self._edges_selectable:\n\t\t\tself._selected_edges.clear()\n\t\t\tself._selected_edges.append(self._edge_hover)\n\t\t\tif self._change_listener is not None:\n\t\t\t\tself._change_listener.on_edge_selected(self._edge_hover)\n\t\t\tself.update()\n\n\t\tif self._area_hover is not None and self._areas_selectable and self._edge_hover is None:\n\t\t\tself._selected_areas.clear()\n\t\t\tself._selected_areas.append(self._area_hover)\n\t\t\tif self._change_listener is not None:\n\t\t\t\tself._change_listener.on_area_selected(self._area_hover)\n\t\t\tself.update()\n\n\t@property\n\tdef show_areas(self):\n\t\treturn self._show_areas\n\n\t@show_areas.setter\n\tdef show_areas(self, value):\n\t\tself._show_areas = value\n\t\tself.update()\n\n\t@property\n\tdef areas_selectable(self):\n\t\treturn self._areas_selectable\n\n\t@areas_selectable.setter\n\tdef areas_selectable(self, value):\n\t\tself._areas_selectable = value\n\n\tdef set_sketch(self, sketch):\n\t\tself._sketch = sketch\n\t\tself.update()\n\n\t@property\n\tdef edges_selectable(self):\n\t\treturn self._edges_selectable\n\n\t@edges_selectable.setter\n\tdef edges_selectable(self, value):\n\t\tself._edges_selectable = value\n\n\t@property\n\tdef keypoints_selectable(self):\n\t  return self._keypoints_selectable\n\n\t@keypoints_selectable.setter\n\tdef keypoints_selectable(self, value):\n\t\tself._keypoints_selectable = value\n\n\tdef set_change_listener(self, change_listener):\n\t\tself._change_listener = change_listener\n\n\tdef paintEvent(self, event):\n\t\tqp = QPainter()\n\t\tqp.begin(self)\n\t\tqp.setRenderHint(QPainter.Antialiasing)\n\n\t\tqp.fillRect(event.rect(), QColor(255, 255, 255))\n\t\thalf_width = self.width() / 2\n\t\thalf_height = self.height() / 2\n\t\tcenter = Vertex(half_width, half_height)\n\t\tif self._sketch is not None:\n\t\t\tlimits = self._sketch.get_limits()\n\t\t\tsketch_width = limits[2] - limits[0]\n\t\t\tsketch_height = limits[3] - limits[1]\n\t\t\tscale_x = self.width() / sketch_width\n\t\t\tscale_y = self.height() / sketch_height\n\t\t\tscale = min(scale_x, scale_y) * 0.9\n\n\t\t\tpens = create_pens(self._doc, 6000/scale, QColor(0, 0, 0))\n\t\t\tpens_hover = create_pens(self._doc, 6000/scale, QColor(100, 100, 200), 1)\n\t\t\tpens_select_high = create_pens(self._doc, 6000/scale, QColor(255, 0, 0), 2)\n\t\t\tpens_select = create_pens(self._doc, 6000/scale, QColor(255, 255, 255))\n\n\t\t\toffset = Vertex(-limits[0] - sketch_width / 2, -limits[1] - sketch_height / 2)\n\t\t\tdraw_sketch(qp, self._sketch, scale, 1/scale, offset, center, 0, pens, {})\n\n\t\t\tqp.save()\n\t\t\tqp.translate(center.x, center.y)\n\t\t\tqp.scale(scale, scale)\n\t\t\tqp.translate(offset.x, -offset.y)\n\t\t\tfor edge in self._selected_edges:\n\t\t\t\tdraw_edge(edge, qp, pens_select_high, None)\n\t\t\tfor edge in self._selected_edges:\n\t\t\t\tdraw_edge(edge, qp, pens_select, None)\n\t\t\tif self._keypoints_selectable:\n\t\t\t\tqp.setPen(pens['default'])\n\t\t\t\tfor kp in self._sketch.get_keypoints():\n\t\t\t\t\tdraw_kp(qp, kp, scale)\n\t\t\t\tif self._kp_hover:\n\t\t\t\t\tqp.setPen(pens_hover['default'])\n\t\t\t\t\tdraw_kp(qp, self._kp_hover, scale)\n\t\t\tif len(self._selected_kps) > 0:\n\t\t\t\tqp.setPen(pens_select_high['default'])\n\t\t\t\tfor kp in self._selected_kps:\n\t\t\t\t\tdraw_kp(qp, kp, scale)\n\t\t\tif self._edge_hover is not None:\n\t\t\t\tdraw_edge(self._edge_hover, qp, pens_hover, None)\n\t\t\tif self._show_areas:\n\t\t\t\tqp.setPen(pens['default'])\n\t\t\t\tfor area in self._sketch.get_areas():\n\t\t\t\t\tdraw_area(area, qp, True, QBrush(QColor(150, 150, 150, 80)), 1/scale, None)\n\t\t\t\tfor area in self._selected_areas:\n\t\t\t\t\tdraw_area(area, qp, True, QBrush(QColor(150, 150, 200, 150)), 1/scale, None)\n\t\t\t\tif self._area_hover is not None:\n\t\t\t\t\tdraw_area(self._area_hover, qp, True, QBrush(QColor(150, 150, 200, 80)), 1/scale, None)\n\t\t\tqp.restore()\n\n\t\tqp.end()\nBusiness/ParameterActions.py\ndef remove_standard(parameters_object: Parameters, standard_name):\n\tparameters_object.remove_standard(standard_name)\nData/Proformer.py\nclass ProformerType(Enum):\n\tCircular = 0\n\tDiamond = 1\n\tTriangular = 2\n\tSquare = 3\n\tRectangular = 4\n\tMirror = 5\n\tMirrorX = 6\n\tMirrorY = 7\n\tMirrorXY = 8\nBusiness/ParameterActions.py\ndef create_new_standard(parameters_object: Parameters, standard_name):\n\tparameters_object.make_standard(standard_name)\nData/Axis.py\nclass Axis(NamedObservableObject, IdObject):\n\tdef __init__(self, document, name=\"New Axis\"):\n\t\tNamedObservableObject.__init__(self, name)\n\t\tIdObject.__init__(self)\n\t\tself._doc = document\n\t\tself._sketch = None\n\t\tself._edge = None\n\t\tself._pm = None\n\t\tself._origo = Vertex()\n\t\tself._direction = Vertex(1, 1, 1)\n\n\t@property\n\tdef direction(self):\n\t\treturn self._direction\n\n\t@property\n\tdef origo(self):\n\t\treturn self._origo\n\n\tdef on_edge_changed(self, event):\n\t\told_value = self._origo\n\t\tkps = self._edge.get_end_key_points()\n\t\tself._origo.x = kps[0].x\n\t\tself._origo.y = kps[0].y\n\t\tself._origo.z = kps[0].z\n\t\tself._direction.xyz = kps[1].xyz - kps[0].xyz\n\t\tself.changed(ChangeEvent(self, ChangeEvent.ObjectChanged, event.sender))\n\t\tself.changed(ValueChangeEvent(self, 'origo', old_value, self._origo))\n\t\tself._pm = None\n\t\tif event.type == ChangeEvent.Deleted:\n\t\t\tevent.sender.remove_change_handler(self.on_edge_changed)\n\t\t\tself._sketch = None\n\n\tdef set_edge_governor(self, edge, sketch):\n\t\tif self._edge is not None:\n\t\t\tself._edge.remove_change_handler(self.on_edge_changed)\n\t\tself._edge = edge\n\t\tself._sketch = sketch\n\t\tkps = self._edge.get_end_key_points()\n\t\tself._origo.x = kps[0].x\n\t\tself._origo.y = kps[0].y\n\t\tself._origo.z = kps[0].z\n\t\tself._direction.xyz = kps[1].xyz - kps[0].xyz\n\t\tself._edge.add_change_handler(self.on_edge_changed)\n\n\tdef get_projection_matrix(self):\n\t\tif self._pm is None:\n\t\t\tif self._direction.z == 0:\n\t\t\t\tangle = atan2(self._direction.y, self._direction.x) + pi / 2\n\t\t\telif self._direction.x == 0:\n\t\t\t\tangle = atan2(self._direction.y, self._direction.z) + pi / 2\n\t\t\telse:\n\t\t\t\tangle = atan2(self._direction.x, self._direction.z) + pi / 2\n\t\t\td2 = np.array([cos(angle), sin(angle), self._direction.z])\n\t\t\tcp = np.cross(self._direction.xyz, d2)\n\t\t\td2 = cp / np.linalg.norm(cp)\n\t\t\tcp = np.cross(self._direction.xyz, d2)\n\t\t\td3 = cp / np.linalg.norm(cp)\n\t\t\td1 = self._direction.xyz / np.linalg.norm(self._direction.xyz)\n\t\t\tpm = np.array([d1, d2, d3])\n\t\t\tself._pm = pm\n\t\telse:\n\t\t\tpm = self._pm\n\t\treturn pm\n\n\tdef distance(self, point):\n\t\tp1 = self._origo.xyz\n\t\tpm = self.get_projection_matrix()\n\t\tnewp = pm.dot(point.xyz - p1)\n\t\tnewp[0] = 0.0\n\t\tdistance = np.linalg.norm(newp)\n\t\treturn distance\n\n\tdef distance_xyz(self, point):\n\t\tp1 = self._origo.xyz\n\t\tpm = self.get_projection_matrix()\n\t\tnewp = pm.dot(point - p1)\n\t\tnewp[0] = 0.0\n\t\tdistance = np.linalg.norm(newp)\n\t\treturn distance\n\n\tdef project_point(self, point):\n\t\tpm = self.get_projection_matrix()\n\t\tnewp = pm.dot(point.xyz - self._origo.xyz)\n\t\treturn newp[0] * pm[0] + self._origo.xyz\n\n\tdef project_point_xyz(self, point):\n\t\tpm = self.get_projection_matrix()\n\t\tnewp = pm.dot(point - self._origo.xyz)\n\t\treturn newp[0] * pm[0] + self._origo.xyz\n\n\t@property\n\tdef _sketch_uid(self):\n\t\tif self._sketch is None:\n\t\t\treturn None\n\t\telse:\n\t\t\treturn self._sketch.uid\n\n\t@property\n\tdef _edge_uid(self):\n\t\tif self._edge is None:\n\t\t\treturn None\n\t\telse:\n\t\t\treturn self._edge.uid\n\n\tdef serialize_json(self):\n\t\treturn {\n\t\t\t'no': NamedObservableObject.serialize_json(self),\n\t\t\t'uid': IdObject.serialize_json(self),\n\t\t\t'sketch_uid': self._sketch_uid,\n\t\t\t'edge_uid': self._edge_uid,\n\t\t\t'origo': self._origo,\n\t\t\t'direction': self._direction\n\t\t}\n\n\t@staticmethod\n\tdef deserialize(data, document):\n\t\taxis = Axis(document)\n\t\tif data is not None:\n\t\t\taxis.deserialize_data(data)\n\t\treturn axis\n\n\tdef deserialize_data(self, data):\n\t\tIdObject.deserialize_data(self, data.get('uid', {'uid': self.uid}))\n\t\tNamedObservableObject.deserialize_data(self, data['no'])\n\t\tsketch_uid = data['sketch_uid']\n\t\tif sketch_uid is not None:\n\t\t\tself._sketch = self._doc.get_geometries().get_geometry(sketch_uid)\n\t\tedge_uid = data['edge_uid']\n\t\tif self._sketch is not None and edge_uid is not None:\n\t\t\tself._edge = self._sketch.get_edge(edge_uid)\n\t\t\tself._edge.add_change_handler(self.on_edge_changed)\n\t\tself._origo = Vertex.deserialize(data['origo'])\n\t\tself._direction = Vertex.deserialize(data['direction'])\n\t\tif self._edge is not None:\n\t\t\tself.on_edge_changed(ChangeEvent(self, ChangeEvent.ObjectChanged, self._edge))\nGUI/init.py\ndef formula_from_locale(formula):\n\tlocale = QLocale()\n\tif locale.decimalPoint() == \",\":\n\t\treturn formula.replace(\",\", \".\").replace(\";\", \",\")\n\treturn formula\nGUI/init.py\ndef tr(string, context_name='app'):\n\tvalue = QCoreApplication.translate(context_name, string)\n\ttry:\n\t\tcontext = contexts[context_name]\n\texcept KeyError:\n\t\tcontexts[context_name] = {}\n\t\tcontext = contexts[context_name]\n\tcontext[string] = value\n\treturn value\nGUI/init.py\ndef gui_scale():\n\tscreen = QApplication.screens()[0];\n\tdpi = screen.logicalDotsPerInch()\n\treturn dpi / 96\nData/Parameters.py\nclass Parameters(ParametersBase):\n\tdef __init__(self, name, parent=None):\n\t\tParametersBase.__init__(self, name)\n\t\tself._parameter_list = []\n\t\tself._params = {}\n\t\tself._parent = parent\n\t\tself._custom_name_getter = None\n\t\tself._standards = {}\n\t\tself._current_standard_name = \"Normal\"\n\t\tself._current_type_name = \"Default\"\n\t\tself._current_type = self.make_type(self._current_standard_name, self._current_type_name)\n\n\t@property\n\tdef document(self):\n\t\tif self._parent is None:\n\t\t\treturn self\n\t\telse:\n\t\t\treturn self._parent.document\n\n\t@property\n\tdef parent(self):\n\t\treturn self._parent\n\n\tdef param_in_current_type(self, param):\n\t\tif self._current_type is None:\n\t\t\treturn False\n\t\treturn param.uid in self._current_type\n\n\tdef make_standard(self, name):\n\t\tstandard = {}\n\t\tself._standards[name] = standard\n\t\treturn standard\n\n\t@property\n\tdef standards(self):\n\t\treturn list(self._standards.keys())\n\n\t@property\n\tdef standard(self):\n\t\treturn self._current_standard_name\n\n\t@standard.setter\n\tdef standard(self, value):\n\t\tif value in self._standards:\n\t\t\tself._current_standard_name = value\n\t\t\tself._current_type_name = \"\"\n\t\t\tself._current_type = None\n\n\t@property\n\tdef types(self):\n\t\treturn self._standards[self._current_standard_name].keys()\n\n\tdef get_types_from_standard(self, standard):\n\t\tif standard in self._standards:\n\t\t\treturn list(self._standards[standard].keys())\n\t\treturn []\n\n\tdef make_type(self, standard_name, type_name):\n\t\tif standard_name not in self._standards:\n\t\t\tstandard = {}\n\t\t\tself._standards[standard_name] = standard\n\t\telse:\n\t\t\tstandard = self._standards[standard_name]\n\t\ttype = {}\n\t\tstandard[type_name] = type\n\t\treturn type\n\n\t@property\n\tdef type(self):\n\t\treturn self._current_type_name\n\n\t@type.setter\n\tdef type(self, type_name):\n\t\tif type_name in self._standards[self._current_standard_name]:\n\t\t\tself._current_type = self._standards[self._current_standard_name][type_name]\n\t\t\tself._current_type_name = type_name\n\t\t\tif self._current_type is None:\n\t\t\t\treturn\n\t\t\tfor param_definition_tuple in self._current_type.items():\n\t\t\t\tuid = param_definition_tuple[0]\n\t\t\t\tval = param_definition_tuple[1]\n\t\t\t\tif uid in self._params:\n\t\t\t\t\tparam = self._params[uid]\n\t\t\t\t\told_value = param.value\n\t\t\t\t\tparam.internal_formula = val['if']\n\t\t\t\t\tparam.internal_value = param.evaluate(None)\n\t\t\t\t\tchange_object = {\n\t\t\t\t\t\t'new value': param.value,\n\t\t\t\t\t\t'old value': old_value,\n\t\t\t\t\t\t'instance': None\n\t\t\t\t\t}\n\t\t\t\t\tparam.changed(ChangeEvent(param, ChangeEvent.ValueChanged, change_object))\n\t\t\tself.changed(ChangeEvent(self, ChangeEvent.ObjectChanged, self))\n\n\tdef _add_parameter_object(self, param):\n\t\tparam.add_change_handler(self.on_parameter_changed)\n\t\tself.changed(ChangeEvent(self, ChangeEvent.BeforeObjectAdded, param))\n\t\tself._params[param.uid] = param\n\t\tself._parameter_list.append(param.uid)\n\t\tself.changed(ChangeEvent(self, ChangeEvent.ObjectAdded, param))\n\n\tdef _remove_parameter_object(self, uid):\n\t\tif uid in self._params:\n\t\t\tself._params.pop(uid)\n\n\tdef get_parameter_by_uid(self, uid) -> Parameter:\n\t\tif uid in self._params:\n\t\t\treturn self._params[uid]\n\t\telif self._parent is not None:\n\t\t\treturn self._parent.get_parameter_by_uid(uid)\n\t\telse:\n\t\t\treturn None\n\n\tdef get_parameter_by_name(self, name) -> Parameter:\n\t\tparam = None\n\t\tfor prm in self._params.values():\n\t\t\tif prm.name == name:\n\t\t\t\tparam = prm\n\t\tif param is None and self._custom_name_getter is not None:\n\t\t\tparam = self._custom_name_getter(name)\n\t\tif param is None and self._parent is not None:\n\t\t\tparam = self._parent.get_parameter_by_name(name)\n\n\t\treturn param\n\n\tdef get_all_local_parameters(self):\n\t\tparams = list(self._params.items())\n\t\treturn params\n\n\tdef get_all_parameters(self):\n\t\tparams = list(self._params.values())\n\t\tif self._parent is not None:\n\t\t\tparams.extend(self._parent.get_all_parameters())\n\t\treturn params\n\n\tdef create_parameter(self, name=None, value=0.0):\n\t\tif name is None:\n\t\t\tif self._parent is None:\n\t\t\t\tname = \"Global\" + str(len(self._parameter_list))\n\t\t\telse:\n\t\t\t\tname = self.name + str(len(self._parameter_list))\n\t\tparam = Parameter(self, name, value)\n\t\tself._add_parameter_object(param)\n\t\treturn param\n\n\tdef delete_parameter(self, uid):\n\t\tparam = self.get_parameter_by_uid(uid)\n\t\tif param is not None:\n\t\t\tparam.remove_change_handler(self.on_parameter_changed)\n\t\t\tself.changed(ChangeEvent(self, ChangeEvent.BeforeObjectRemoved, param))\n\t\t\tself._parameter_list.remove(uid)\n\t\t\tself.changed(ChangeEvent(self, ChangeEvent.ObjectRemoved, param))\n\t\t\tself._remove_parameter_object(uid)\n\t\t\tparam.changed(ChangeEvent(param, ChangeEvent.Deleted, param))\n\n\tdef delete_parameters(self, params):\n\t\tfor param in params:\n\t\t\tif param.uid in self._parameter_list:\n\t\t\t\tself.delete_parameter(param.uid)\n\n\tdef on_parameter_changed(self, event):\n\t\tparam = event.sender\n\t\tself.changed(ChangeEvent(self, event.type, event.sender))\n\t\tif self._current_type is not None and param.uid in self._params:\n\t\t\tif 'instance' in event.object and 'new formula' in event.object:\n\t\t\t\tif event.object['instance'] is None and event.object['new formula'] != event.object['old formula']:\n\n\t\t\t\t\tif param.uid in self._current_type:\n\t\t\t\t\t\tpredef = self._current_type[param.uid]\n\t\t\t\t\telse:\n\t\t\t\t\t\tpredef = {}\n\t\t\t\t\t\tself._current_type[param.uid] = predef\n\t\t\t\t\tpredef['if'] = param.internal_formula\n\t\t\t\t\tpredef['iv'] = param.internal_value\n\n\tdef get_index_of(self, parameter):\n\t\tif parameter.uid in self._parameter_list:\n\t\t\treturn self._parameter_list.index(parameter.uid)\n\t\telse:\n\t\t\treturn -1\n\n\t@property\n\tdef length(self):\n\t\treturn len(self._parameter_list)\n\n\t@property\n\tdef length_all(self):\n\t\tif self._parent is not None:\n\t\t\treturn self._parent.length_all + self.length\n\t\telse:\n\t\t\treturn self.length\n\n\tdef get_parameter_item(self, index):\n\t\tif index >= self.length:\n\t\t\treturn self._parent.get_parameter_item(index - self.length)\n\t\telse:\n\t\t\tuid = self._parameter_list[index]\n\t\tparam = self.get_parameter_by_uid(uid)\n\t\treturn param\n\n\tdef serialize_json(self):\n\t\treturn {\n\t\t\t'name': self._name,\n\t\t\t'params': self._params,\n\t\t\t'parameter_list': self._parameter_list,\n\t\t\t'pps': self._standards,\n\t\t\t'csn': self._current_standard_name,\n\t\t\t'ctn': self._current_type_name\n\t\t}\n\n\t@staticmethod\n\tdef deserialize(data, parent):\n\t\tparam = Parameters(parent)\n\t\tparam.deserialize_data(data)\n\t\treturn param\n\n\tdef deserialize_data(self, data):\n\t\tself._parameter_list = data.get('parameter_list', [])\n\t\tself._name = data.get('name', 'name missing')\n\t\tself._standards = data.get('pps', self._standards)\n\t\tself._current_standard_name = data.get(\"csn\", self._current_standard_name)\n\t\tself._current_type_name = data.get(\"ctn\", self._current_type_name)\n\t\tself._current_type = self._standards[self._current_standard_name][self._current_type_name]\n\t\tfor param_data in data.get('params', {}).items():\n\t\t\tparam = Parameter.deserialize(param_data[1], self)\n\t\t\tself._params[param.uid] = param\n\t\t\tparam.add_change_handler(self.on_parameter_changed)\n\n\t\tfor param_tuple in self._params.items():\n\t\t\tif param_tuple[1].formula != '':\n\t\t\t\ttry:\n\t\t\t\t\tparam_tuple[1].value = param_tuple[1].formula\n\t\t\t\texcept Exception as e:\n\t\t\t\t\tpass\nBusiness/ParameterActions.py\ndef remove_type(parameters_object: Parameters, standard_name, type_name):\n\tparameters_object.remove_type(standard_name, type_name)\nBusiness/ParameterActions.py\ndef create_new_type(parameters_object: Parameters, standard_name, type_name):\n\tparameters_object.make_type(standard_name, type_name)\nfrom math import pi\nfrom PyQt5 import QtGui\nfrom PyQt5.QtCore import QLocale\nfrom PyQt5.QtWidgets import QComboBox, QLineEdit, QHBoxLayout, QTableWidget, QPushButton, QTableWidgetItem, QInputDialog\nfrom PyQt5.QtWidgets import QDialog\nfrom PyQt5.QtWidgets import QDialogButtonBox\nfrom PyQt5.QtWidgets import QGridLayout\nfrom PyQt5.QtWidgets import QLabel\nfrom PyQt5.QtWidgets import QVBoxLayout\nfrom PyQt5.QtWidgets import QWidget\nfrom Business.ParameterActions import create_new_standard, create_new_type, remove_standard, remove_type\nfrom Data.Axis import Axis\nfrom Data.Parameters import Parameters\nfrom Data.Proformer import ProformerType\nfrom GUI.Widgets.SketchViewWidget import SketchViewWidget\nfrom GUI.init import formula_from_locale, gui_scale, tr\n\t\tcontents_layout.addWidget(self._sa_combo_box, 1, 1)\n\t\tcontents_layout.addWidget(self._ea_combo_box, 2, 1)\n\t\tself.layout().addWidget(contents_widget)\n\t\tdialog_buttons = QDialogButtonBox(QDialogButtonBox.Cancel | QDialogButtonBox.Ok)\n\t\tdialog_buttons.accepted.connect(self.accept)\n\t\tdialog_buttons.rejected.connect(self.reject)\n\t\tself.layout().addWidget(dialog_buttons)\n\n\tdef radius_param(self):\n\t\treturn self._radius_combo_box.currentText()\n\n\tdef start_angle_param(self):\n\t\treturn self._sa_combo_box.currentText()\n\n\tdef end_angle_param(self):\n\t\treturn self._ea_combo_box.currentText()\n\n\nclass StandardTypeManager(QDialog):\n\tdef __init__(self, parent, parameters):\n\t\tQDialog.__init__(self, parent)\n\t\tself._parameters = parameters\n\t\tself.setLayout(QVBoxLayout())\n\t\tdialog_buttons = QDialogButtonBox(QDialogButtonBox.Close)\n\t\tdialog_buttons.close.connect(self.accept)\n\t\tself.layout().addWidget(dialog_buttons)\n\n\nclass SketchMirrorDialog(QDialog):\n\tdef __init__(self, parent, sketch):\n\t\tQDialog.__init__(self, parent)\n\t\tself._sketch = sketch\n\t\tself.setWindowTitle(tr(\"Mirror\", 'dialogs'))\n\t\tself.setLayout(QVBoxLayout())\n\t\tcontents_widget = QWidget(self)\n\t\tcontents_layout = QGridLayout()\n\t\tcontents_widget.setLayout(contents_layout)\n\t\tself._mirror_type = ProformerType.Mirror\n\n\t\tcontents_layout.addWidget(QLabel(tr(\"Mirror type\", 'dialogs')), 0, 0)\n\t\tcontents_layout.addWidget(QLabel(tr(\"Mirror line\", 'dialogs')), 1, 0)\n\n\t\tself._mirror_type_combo_box = QComboBox()\n\t\tself._mirror_line_combo_box = QComboBox()\n\t\tself._mirror_type_combo_box.currentIndexChanged.connect(self.on_mirror_type_selection_changed)\n\n\t\tself._mirror_type_combo_box.addItem(ProformerType.Mirror.name, ProformerType.Mirror.value)\n\t\tself._mirror_type_combo_box.addItem(ProformerType.MirrorX.name, ProformerType.MirrorX.value)\n\t\tself._mirror_type_combo_box.addItem(ProformerType.MirrorY.name, ProformerType.MirrorY.value)\n\t\tself._mirror_type_combo_box.addItem(ProformerType.MirrorXY.name, ProformerType.MirrorXY.value)\n\t\tself._mirror_type_combo_box.setEditable(True)\n\t\t#self._mirror_line_combo_box.addItems(self._params)\n\t\tself._mirror_line_combo_box.setEditable(True)\n\t\t#self._ea_combo_box.addItems(self._params)\n\t\t#self._ea_combo_box.setEditable(True)\n\t\tcontents_layout.addWidget(self._mirror_type_combo_box, 0, 1)\n\t\tcontents_layout.addWidget(self._mirror_line_combo_box, 1, 1)\n\n\t\tself.layout().addWidget(contents_widget)\n\t\tself._sketch_view = SketchViewWidget(self, sketch, sketch.document)\n\t\tself._sketch_view.set_change_listener(self)\n\t\tself._sketch_view.edges_selectable = True\n\t\t#self._sketch_view.set_sketch(sketch)\n\t\tself.layout().addWidget(self._sketch_view)\n\n\t\tdialog_buttons = QDialogButtonBox(QDialogButtonBox.Cancel | QDialogButtonBox.Ok)\n\t\tdialog_buttons.accepted.connect(self.accept)\n\t\tdialog_buttons.rejected.connect(self.reject)\n\t\tself.layout().addWidget(dialog_buttons)\n\t\tself.fill_mirror_axi()\n\n\t@property\n\tdef mirror_type(self):\n\t\treturn self._mirror_type\n\n\t@property\n\tdef mirror_axis(self):\n\t\treturn self._sketch.get_edge_by_name(self._mirror_line_combo_box.currentText())\n\n\tdef on_edge_selected(self, edge):\n\t\tself._mirror_line_combo_box.setCurrentText(edge.name)\n\n\tdef on_area_selected(self, area):\n\t\tself._area_combo_box.setCurrentText(area.name)\n\n\tdef on_mirror_type_selection_changed(self):\n\t\tindex = self._mirror_type_combo_box.currentIndex()\n\t\tif index == 0:\n\t\t\tself._mirror_type = ProformerType.Mirror\n\t\t\tself._mirror_line_combo_box.setEnabled(True)\n\t\t\tself._mirror_line_combo_box.setCurrentIndex(0)\n\t\telif index == 1:\n\t\t\tself._mirror_type = ProformerType.MirrorX\n\t\t\tself._mirror_line_combo_box.setEnabled(False)\n\t\t\tself._mirror_line_combo_box.setCurrentText(\"X axis\")\n\t\telif index == 2:\n\t\t\tself._mirror_type = ProformerType.MirrorY\n\t\t\tself._mirror_line_combo_box.setEnabled(False)\n\t\t\tself._mirror_line_combo_box.setCurrentText(\"Y axis\")\n\t\telse:\n\t\t\tself._mirror_type = ProformerType.MirrorXY\n\t\t\tself._mirror_line_combo_box.setEnabled(False)\n\t\t\tself._mirror_line_combo_box.setCurrentText(\"XY axis\")\n\n\tdef fill_mirror_axi(self):\n\t\tself._mirror_line_combo_box.clear()\n\t\t# self._mirror_line_combo_box.addItems(['X Axis', 'Y Axis'])\n\t\tedge_names = []\n\t\tsketch = self._sketch\n\t\tself._sketch_view.set_sketch(sketch)\n\t\tfor edge in sketch.get_edges():\n\t\t\tedge_names.append(edge.name)\n\t\tedge_names.sort()\n\t\tself._mirror_line_combo_box.addItems(edge_names)\n\nclass ParameterSelectWidget():\n\tdef __init__(self, parent, parameters, layout, row, caption=\"\"):\n\t\tself._parameters = parameters\n\n\t\tself._caption_label = QLabel(caption)\nNext line of code:\n", "input": "from math import pi\nfrom PyQt5 import QtGui\nfrom PyQt5.QtCore import QLocale\nfrom PyQt5.QtWidgets import QComboBox, QLineEdit, QHBoxLayout, QTableWidget, QPushButton, QTableWidgetItem, QInputDialog\nfrom PyQt5.QtWidgets import QDialog\nfrom PyQt5.QtWidgets import QDialogButtonBox\nfrom PyQt5.QtWidgets import QGridLayout\nfrom PyQt5.QtWidgets import QLabel\nfrom PyQt5.QtWidgets import QVBoxLayout\nfrom PyQt5.QtWidgets import QWidget\nfrom Business.ParameterActions import create_new_standard, create_new_type, remove_standard, remove_type\nfrom Data.Axis import Axis\nfrom Data.Parameters import Parameters\nfrom Data.Proformer import ProformerType\nfrom GUI.Widgets.SketchViewWidget import SketchViewWidget\nfrom GUI.init import formula_from_locale, gui_scale, tr\n\t\tcontents_layout.addWidget(self._sa_combo_box, 1, 1)\n\t\tcontents_layout.addWidget(self._ea_combo_box, 2, 1)\n\t\tself.layout().addWidget(contents_widget)\n\t\tdialog_buttons = QDialogButtonBox(QDialogButtonBox.Cancel | QDialogButtonBox.Ok)\n\t\tdialog_buttons.accepted.connect(self.accept)\n\t\tdialog_buttons.rejected.connect(self.reject)\n\t\tself.layout().addWidget(dialog_buttons)\n\n\tdef radius_param(self):\n\t\treturn self._radius_combo_box.currentText()\n\n\tdef start_angle_param(self):\n\t\treturn self._sa_combo_box.currentText()\n\n\tdef end_angle_param(self):\n\t\treturn self._ea_combo_box.currentText()\n\n\nclass StandardTypeManager(QDialog):\n\tdef __init__(self, parent, parameters):\n\t\tQDialog.__init__(self, parent)\n\t\tself._parameters = parameters\n\t\tself.setLayout(QVBoxLayout())\n\t\tdialog_buttons = QDialogButtonBox(QDialogButtonBox.Close)\n\t\tdialog_buttons.close.connect(self.accept)\n\t\tself.layout().addWidget(dialog_buttons)\n\n\nclass SketchMirrorDialog(QDialog):\n\tdef __init__(self, parent, sketch):\n\t\tQDialog.__init__(self, parent)\n\t\tself._sketch = sketch\n\t\tself.setWindowTitle(tr(\"Mirror\", 'dialogs'))\n\t\tself.setLayout(QVBoxLayout())\n\t\tcontents_widget = QWidget(self)\n\t\tcontents_layout = QGridLayout()\n\t\tcontents_widget.setLayout(contents_layout)\n\t\tself._mirror_type = ProformerType.Mirror\n\n\t\tcontents_layout.addWidget(QLabel(tr(\"Mirror type\", 'dialogs')), 0, 0)\n\t\tcontents_layout.addWidget(QLabel(tr(\"Mirror line\", 'dialogs')), 1, 0)\n\n\t\tself._mirror_type_combo_box = QComboBox()\n\t\tself._mirror_line_combo_box = QComboBox()\n\t\tself._mirror_type_combo_box.currentIndexChanged.connect(self.on_mirror_type_selection_changed)\n\n\t\tself._mirror_type_combo_box.addItem(ProformerType.Mirror.name, ProformerType.Mirror.value)\n\t\tself._mirror_type_combo_box.addItem(ProformerType.MirrorX.name, ProformerType.MirrorX.value)\n\t\tself._mirror_type_combo_box.addItem(ProformerType.MirrorY.name, ProformerType.MirrorY.value)\n\t\tself._mirror_type_combo_box.addItem(ProformerType.MirrorXY.name, ProformerType.MirrorXY.value)\n\t\tself._mirror_type_combo_box.setEditable(True)\n\t\t#self._mirror_line_combo_box.addItems(self._params)\n\t\tself._mirror_line_combo_box.setEditable(True)\n\t\t#self._ea_combo_box.addItems(self._params)\n\t\t#self._ea_combo_box.setEditable(True)\n\t\tcontents_layout.addWidget(self._mirror_type_combo_box, 0, 1)\n\t\tcontents_layout.addWidget(self._mirror_line_combo_box, 1, 1)\n\n\t\tself.layout().addWidget(contents_widget)\n\t\tself._sketch_view = SketchViewWidget(self, sketch, sketch.document)\n\t\tself._sketch_view.set_change_listener(self)\n\t\tself._sketch_view.edges_selectable = True\n\t\t#self._sketch_view.set_sketch(sketch)\n\t\tself.layout().addWidget(self._sketch_view)\n\n\t\tdialog_buttons = QDialogButtonBox(QDialogButtonBox.Cancel | QDialogButtonBox.Ok)\n\t\tdialog_buttons.accepted.connect(self.accept)\n\t\tdialog_buttons.rejected.connect(self.reject)\n\t\tself.layout().addWidget(dialog_buttons)\n\t\tself.fill_mirror_axi()\n\n\t@property\n\tdef mirror_type(self):\n\t\treturn self._mirror_type\n\n\t@property\n\tdef mirror_axis(self):\n\t\treturn self._sketch.get_edge_by_name(self._mirror_line_combo_box.currentText())\n\n\tdef on_edge_selected(self, edge):\n\t\tself._mirror_line_combo_box.setCurrentText(edge.name)\n\n\tdef on_area_selected(self, area):\n\t\tself._area_combo_box.setCurrentText(area.name)\n\n\tdef on_mirror_type_selection_changed(self):\n\t\tindex = self._mirror_type_combo_box.currentIndex()\n\t\tif index == 0:\n\t\t\tself._mirror_type = ProformerType.Mirror\n\t\t\tself._mirror_line_combo_box.setEnabled(True)\n\t\t\tself._mirror_line_combo_box.setCurrentIndex(0)\n\t\telif index == 1:\n\t\t\tself._mirror_type = ProformerType.MirrorX\n\t\t\tself._mirror_line_combo_box.setEnabled(False)\n\t\t\tself._mirror_line_combo_box.setCurrentText(\"X axis\")\n\t\telif index == 2:\n\t\t\tself._mirror_type = ProformerType.MirrorY\n\t\t\tself._mirror_line_combo_box.setEnabled(False)\n\t\t\tself._mirror_line_combo_box.setCurrentText(\"Y axis\")\n\t\telse:\n\t\t\tself._mirror_type = ProformerType.MirrorXY\n\t\t\tself._mirror_line_combo_box.setEnabled(False)\n\t\t\tself._mirror_line_combo_box.setCurrentText(\"XY axis\")\n\n\tdef fill_mirror_axi(self):\n\t\tself._mirror_line_combo_box.clear()\n\t\t# self._mirror_line_combo_box.addItems(['X Axis', 'Y Axis'])\n\t\tedge_names = []\n\t\tsketch = self._sketch\n\t\tself._sketch_view.set_sketch(sketch)\n\t\tfor edge in sketch.get_edges():\n\t\t\tedge_names.append(edge.name)\n\t\tedge_names.sort()\n\t\tself._mirror_line_combo_box.addItems(edge_names)\n\nclass ParameterSelectWidget():\n\tdef __init__(self, parent, parameters, layout, row, caption=\"\"):\n\t\tself._parameters = parameters\n\n\t\tself._caption_label = QLabel(caption)\n", "context": "GUI/Widgets/SketchViewWidget.py\nclass SketchViewWidget(QWidget):\n\tdef __init__(self, parent, sketch, document):\n\t\tQWidget.__init__(self, parent)\n\t\tself._doc = document\n\t\tself._sketch = sketch\n\t\tself.setMinimumHeight(250)\n\t\tself.setMinimumWidth(250)\n\t\tself.setMouseTracking(True)\n\t\tself._show_areas = False\n\t\tself._areas_selectable = False\n\t\tself._edges_selectable = False\n\t\tself._keypoints_selectable = False\n\t\tself._change_listener = None\n\t\tself._selected_areas = []\n\t\tself._selected_edges = []\n\t\tself._selected_kps = []\n\t\tself._area_hover = None\n\t\tself._edge_hover = None\n\t\tself._kp_hover = None\n\t\tself._mouse_position = None\n\n\t@property\n\tdef selected_kps(self):\n\t    return self._selected_kps\n\n\t@selected_kps.setter\n\tdef selected_kps(self, value):\n\t\tself._selected_kps = value\n\t\tself.update()\n\n\tdef mouseMoveEvent(self, q_mouse_event):\n\t\tposition = q_mouse_event.pos()\n\t\tif self._mouse_position is not None:\n\t\t\tmouse_move_x = self._mouse_position.x() - position.x()\n\t\t\tmouse_move_y = self._mouse_position.y() - position.y()\n\t\telse:\n\t\t\tmouse_move_x = 0\n\t\t\tmouse_move_y = 0\n\t\tself._mouse_position = position\n\t\tif self._sketch is None:\n\t\t\treturn\n\t\tupdate_view = False\n\t\tif self._area_hover is not None or self._edge_hover is not None:\n\t\t\tupdate_view = True\n\t\tself._area_hover = None\n\t\tself._edge_hover = None\n\t\twidth = self.width() / 2\n\t\theight = self.height() / 2\n\t\tlimits = self._sketch.get_limits()\n\t\tsketch_width = limits[2] - limits[0]\n\t\tsketch_height = limits[3] - limits[1]\n\t\tscale_x = self.width() / sketch_width\n\t\tscale_y = self.height() / sketch_height\n\t\tscale = min(scale_x, scale_y) * 0.9\n\t\toffset = Vertex(-limits[0] - sketch_width / 2, -limits[1] - sketch_height / 2)\n\t\tx = (self._mouse_position.x() - width) / scale - offset.x\n\t\ty = -((self._mouse_position.y() - height) / scale + offset.y)\n\n\n\t\tif self._keypoints_selectable:\n\t\t\tfor key_point in self._sketch.get_keypoints():\n\t\t\t\tx1 = key_point.x\n\t\t\t\ty1 = key_point.y\n\t\t\t\tif abs(x1 - x) < 5 / scale and abs(y1 - y) < 5 / scale:\n\t\t\t\t\tself._kp_hover = key_point\n\t\t\t\t\tupdate_view = True\n\t\t\t\t\tbreak\n\t\tif self._edges_selectable:\n\t\t\tsmallest_dist = 10e10\n\t\t\tclosest_edge = None\n\t\t\tfor edge in self._sketch.get_edges():\n\t\t\t\tdist = edge.distance(Vertex(x, y, 0))\n\t\t\t\tif dist < smallest_dist:\n\t\t\t\t\tsmallest_dist = dist\n\t\t\t\t\tclosest_edge = edge\n\t\t\tif smallest_dist * scale < 10:\n\t\t\t\tself._edge_hover = closest_edge\n\t\t\t\tupdate_view = True\n\t\tif self._areas_selectable and self._edge_hover is None:\n\t\t\tfor area in self._sketch.get_areas():\n\t\t\t\tif area.inside(Vertex(x, y, 0)):\n\t\t\t\t\tself._area_hover = area\n\t\t\t\t\tupdate_view = True\n\t\t\t\t\tbreak\n\t\tif update_view:\n\t\t\tself.update()\n\n\tdef mousePressEvent(self, q_mouse_event):\n\t\tself.setFocus()\n\t\tposition = q_mouse_event.pos()\n\t\tif q_mouse_event.button() == 4:\n\t\t\treturn\n\t\tif q_mouse_event.button() == 1:\n\t\t\tpass\n\n\t\tif self._kp_hover is not None and self._keypoints_selectable:\n\t\t\tself._selected_kps.clear()\n\t\t\tself._selected_kps.append(self._kp_hover)\n\t\t\tif self._change_listener is not None:\n\t\t\t\tself._change_listener.on_kp_selected(self._kp_hover)\n\t\t\tself.update()\n\n\t\tif self._edge_hover is not None and self._edges_selectable:\n\t\t\tself._selected_edges.clear()\n\t\t\tself._selected_edges.append(self._edge_hover)\n\t\t\tif self._change_listener is not None:\n\t\t\t\tself._change_listener.on_edge_selected(self._edge_hover)\n\t\t\tself.update()\n\n\t\tif self._area_hover is not None and self._areas_selectable and self._edge_hover is None:\n\t\t\tself._selected_areas.clear()\n\t\t\tself._selected_areas.append(self._area_hover)\n\t\t\tif self._change_listener is not None:\n\t\t\t\tself._change_listener.on_area_selected(self._area_hover)\n\t\t\tself.update()\n\n\t@property\n\tdef show_areas(self):\n\t\treturn self._show_areas\n\n\t@show_areas.setter\n\tdef show_areas(self, value):\n\t\tself._show_areas = value\n\t\tself.update()\n\n\t@property\n\tdef areas_selectable(self):\n\t\treturn self._areas_selectable\n\n\t@areas_selectable.setter\n\tdef areas_selectable(self, value):\n\t\tself._areas_selectable = value\n\n\tdef set_sketch(self, sketch):\n\t\tself._sketch = sketch\n\t\tself.update()\n\n\t@property\n\tdef edges_selectable(self):\n\t\treturn self._edges_selectable\n\n\t@edges_selectable.setter\n\tdef edges_selectable(self, value):\n\t\tself._edges_selectable = value\n\n\t@property\n\tdef keypoints_selectable(self):\n\t  return self._keypoints_selectable\n\n\t@keypoints_selectable.setter\n\tdef keypoints_selectable(self, value):\n\t\tself._keypoints_selectable = value\n\n\tdef set_change_listener(self, change_listener):\n\t\tself._change_listener = change_listener\n\n\tdef paintEvent(self, event):\n\t\tqp = QPainter()\n\t\tqp.begin(self)\n\t\tqp.setRenderHint(QPainter.Antialiasing)\n\n\t\tqp.fillRect(event.rect(), QColor(255, 255, 255))\n\t\thalf_width = self.width() / 2\n\t\thalf_height = self.height() / 2\n\t\tcenter = Vertex(half_width, half_height)\n\t\tif self._sketch is not None:\n\t\t\tlimits = self._sketch.get_limits()\n\t\t\tsketch_width = limits[2] - limits[0]\n\t\t\tsketch_height = limits[3] - limits[1]\n\t\t\tscale_x = self.width() / sketch_width\n\t\t\tscale_y = self.height() / sketch_height\n\t\t\tscale = min(scale_x, scale_y) * 0.9\n\n\t\t\tpens = create_pens(self._doc, 6000/scale, QColor(0, 0, 0))\n\t\t\tpens_hover = create_pens(self._doc, 6000/scale, QColor(100, 100, 200), 1)\n\t\t\tpens_select_high = create_pens(self._doc, 6000/scale, QColor(255, 0, 0), 2)\n\t\t\tpens_select = create_pens(self._doc, 6000/scale, QColor(255, 255, 255))\n\n\t\t\toffset = Vertex(-limits[0] - sketch_width / 2, -limits[1] - sketch_height / 2)\n\t\t\tdraw_sketch(qp, self._sketch, scale, 1/scale, offset, center, 0, pens, {})\n\n\t\t\tqp.save()\n\t\t\tqp.translate(center.x, center.y)\n\t\t\tqp.scale(scale, scale)\n\t\t\tqp.translate(offset.x, -offset.y)\n\t\t\tfor edge in self._selected_edges:\n\t\t\t\tdraw_edge(edge, qp, pens_select_high, None)\n\t\t\tfor edge in self._selected_edges:\n\t\t\t\tdraw_edge(edge, qp, pens_select, None)\n\t\t\tif self._keypoints_selectable:\n\t\t\t\tqp.setPen(pens['default'])\n\t\t\t\tfor kp in self._sketch.get_keypoints():\n\t\t\t\t\tdraw_kp(qp, kp, scale)\n\t\t\t\tif self._kp_hover:\n\t\t\t\t\tqp.setPen(pens_hover['default'])\n\t\t\t\t\tdraw_kp(qp, self._kp_hover, scale)\n\t\t\tif len(self._selected_kps) > 0:\n\t\t\t\tqp.setPen(pens_select_high['default'])\n\t\t\t\tfor kp in self._selected_kps:\n\t\t\t\t\tdraw_kp(qp, kp, scale)\n\t\t\tif self._edge_hover is not None:\n\t\t\t\tdraw_edge(self._edge_hover, qp, pens_hover, None)\n\t\t\tif self._show_areas:\n\t\t\t\tqp.setPen(pens['default'])\n\t\t\t\tfor area in self._sketch.get_areas():\n\t\t\t\t\tdraw_area(area, qp, True, QBrush(QColor(150, 150, 150, 80)), 1/scale, None)\n\t\t\t\tfor area in self._selected_areas:\n\t\t\t\t\tdraw_area(area, qp, True, QBrush(QColor(150, 150, 200, 150)), 1/scale, None)\n\t\t\t\tif self._area_hover is not None:\n\t\t\t\t\tdraw_area(self._area_hover, qp, True, QBrush(QColor(150, 150, 200, 80)), 1/scale, None)\n\t\t\tqp.restore()\n\n\t\tqp.end()\nBusiness/ParameterActions.py\ndef remove_standard(parameters_object: Parameters, standard_name):\n\tparameters_object.remove_standard(standard_name)\nData/Proformer.py\nclass ProformerType(Enum):\n\tCircular = 0\n\tDiamond = 1\n\tTriangular = 2\n\tSquare = 3\n\tRectangular = 4\n\tMirror = 5\n\tMirrorX = 6\n\tMirrorY = 7\n\tMirrorXY = 8\nBusiness/ParameterActions.py\ndef create_new_standard(parameters_object: Parameters, standard_name):\n\tparameters_object.make_standard(standard_name)\nData/Axis.py\nclass Axis(NamedObservableObject, IdObject):\n\tdef __init__(self, document, name=\"New Axis\"):\n\t\tNamedObservableObject.__init__(self, name)\n\t\tIdObject.__init__(self)\n\t\tself._doc = document\n\t\tself._sketch = None\n\t\tself._edge = None\n\t\tself._pm = None\n\t\tself._origo = Vertex()\n\t\tself._direction = Vertex(1, 1, 1)\n\n\t@property\n\tdef direction(self):\n\t\treturn self._direction\n\n\t@property\n\tdef origo(self):\n\t\treturn self._origo\n\n\tdef on_edge_changed(self, event):\n\t\told_value = self._origo\n\t\tkps = self._edge.get_end_key_points()\n\t\tself._origo.x = kps[0].x\n\t\tself._origo.y = kps[0].y\n\t\tself._origo.z = kps[0].z\n\t\tself._direction.xyz = kps[1].xyz - kps[0].xyz\n\t\tself.changed(ChangeEvent(self, ChangeEvent.ObjectChanged, event.sender))\n\t\tself.changed(ValueChangeEvent(self, 'origo', old_value, self._origo))\n\t\tself._pm = None\n\t\tif event.type == ChangeEvent.Deleted:\n\t\t\tevent.sender.remove_change_handler(self.on_edge_changed)\n\t\t\tself._sketch = None\n\n\tdef set_edge_governor(self, edge, sketch):\n\t\tif self._edge is not None:\n\t\t\tself._edge.remove_change_handler(self.on_edge_changed)\n\t\tself._edge = edge\n\t\tself._sketch = sketch\n\t\tkps = self._edge.get_end_key_points()\n\t\tself._origo.x = kps[0].x\n\t\tself._origo.y = kps[0].y\n\t\tself._origo.z = kps[0].z\n\t\tself._direction.xyz = kps[1].xyz - kps[0].xyz\n\t\tself._edge.add_change_handler(self.on_edge_changed)\n\n\tdef get_projection_matrix(self):\n\t\tif self._pm is None:\n\t\t\tif self._direction.z == 0:\n\t\t\t\tangle = atan2(self._direction.y, self._direction.x) + pi / 2\n\t\t\telif self._direction.x == 0:\n\t\t\t\tangle = atan2(self._direction.y, self._direction.z) + pi / 2\n\t\t\telse:\n\t\t\t\tangle = atan2(self._direction.x, self._direction.z) + pi / 2\n\t\t\td2 = np.array([cos(angle), sin(angle), self._direction.z])\n\t\t\tcp = np.cross(self._direction.xyz, d2)\n\t\t\td2 = cp / np.linalg.norm(cp)\n\t\t\tcp = np.cross(self._direction.xyz, d2)\n\t\t\td3 = cp / np.linalg.norm(cp)\n\t\t\td1 = self._direction.xyz / np.linalg.norm(self._direction.xyz)\n\t\t\tpm = np.array([d1, d2, d3])\n\t\t\tself._pm = pm\n\t\telse:\n\t\t\tpm = self._pm\n\t\treturn pm\n\n\tdef distance(self, point):\n\t\tp1 = self._origo.xyz\n\t\tpm = self.get_projection_matrix()\n\t\tnewp = pm.dot(point.xyz - p1)\n\t\tnewp[0] = 0.0\n\t\tdistance = np.linalg.norm(newp)\n\t\treturn distance\n\n\tdef distance_xyz(self, point):\n\t\tp1 = self._origo.xyz\n\t\tpm = self.get_projection_matrix()\n\t\tnewp = pm.dot(point - p1)\n\t\tnewp[0] = 0.0\n\t\tdistance = np.linalg.norm(newp)\n\t\treturn distance\n\n\tdef project_point(self, point):\n\t\tpm = self.get_projection_matrix()\n\t\tnewp = pm.dot(point.xyz - self._origo.xyz)\n\t\treturn newp[0] * pm[0] + self._origo.xyz\n\n\tdef project_point_xyz(self, point):\n\t\tpm = self.get_projection_matrix()\n\t\tnewp = pm.dot(point - self._origo.xyz)\n\t\treturn newp[0] * pm[0] + self._origo.xyz\n\n\t@property\n\tdef _sketch_uid(self):\n\t\tif self._sketch is None:\n\t\t\treturn None\n\t\telse:\n\t\t\treturn self._sketch.uid\n\n\t@property\n\tdef _edge_uid(self):\n\t\tif self._edge is None:\n\t\t\treturn None\n\t\telse:\n\t\t\treturn self._edge.uid\n\n\tdef serialize_json(self):\n\t\treturn {\n\t\t\t'no': NamedObservableObject.serialize_json(self),\n\t\t\t'uid': IdObject.serialize_json(self),\n\t\t\t'sketch_uid': self._sketch_uid,\n\t\t\t'edge_uid': self._edge_uid,\n\t\t\t'origo': self._origo,\n\t\t\t'direction': self._direction\n\t\t}\n\n\t@staticmethod\n\tdef deserialize(data, document):\n\t\taxis = Axis(document)\n\t\tif data is not None:\n\t\t\taxis.deserialize_data(data)\n\t\treturn axis\n\n\tdef deserialize_data(self, data):\n\t\tIdObject.deserialize_data(self, data.get('uid', {'uid': self.uid}))\n\t\tNamedObservableObject.deserialize_data(self, data['no'])\n\t\tsketch_uid = data['sketch_uid']\n\t\tif sketch_uid is not None:\n\t\t\tself._sketch = self._doc.get_geometries().get_geometry(sketch_uid)\n\t\tedge_uid = data['edge_uid']\n\t\tif self._sketch is not None and edge_uid is not None:\n\t\t\tself._edge = self._sketch.get_edge(edge_uid)\n\t\t\tself._edge.add_change_handler(self.on_edge_changed)\n\t\tself._origo = Vertex.deserialize(data['origo'])\n\t\tself._direction = Vertex.deserialize(data['direction'])\n\t\tif self._edge is not None:\n\t\t\tself.on_edge_changed(ChangeEvent(self, ChangeEvent.ObjectChanged, self._edge))\nGUI/init.py\ndef formula_from_locale(formula):\n\tlocale = QLocale()\n\tif locale.decimalPoint() == \",\":\n\t\treturn formula.replace(\",\", \".\").replace(\";\", \",\")\n\treturn formula\nGUI/init.py\ndef tr(string, context_name='app'):\n\tvalue = QCoreApplication.translate(context_name, string)\n\ttry:\n\t\tcontext = contexts[context_name]\n\texcept KeyError:\n\t\tcontexts[context_name] = {}\n\t\tcontext = contexts[context_name]\n\tcontext[string] = value\n\treturn value\nGUI/init.py\ndef gui_scale():\n\tscreen = QApplication.screens()[0];\n\tdpi = screen.logicalDotsPerInch()\n\treturn dpi / 96\nData/Parameters.py\nclass Parameters(ParametersBase):\n\tdef __init__(self, name, parent=None):\n\t\tParametersBase.__init__(self, name)\n\t\tself._parameter_list = []\n\t\tself._params = {}\n\t\tself._parent = parent\n\t\tself._custom_name_getter = None\n\t\tself._standards = {}\n\t\tself._current_standard_name = \"Normal\"\n\t\tself._current_type_name = \"Default\"\n\t\tself._current_type = self.make_type(self._current_standard_name, self._current_type_name)\n\n\t@property\n\tdef document(self):\n\t\tif self._parent is None:\n\t\t\treturn self\n\t\telse:\n\t\t\treturn self._parent.document\n\n\t@property\n\tdef parent(self):\n\t\treturn self._parent\n\n\tdef param_in_current_type(self, param):\n\t\tif self._current_type is None:\n\t\t\treturn False\n\t\treturn param.uid in self._current_type\n\n\tdef make_standard(self, name):\n\t\tstandard = {}\n\t\tself._standards[name] = standard\n\t\treturn standard\n\n\t@property\n\tdef standards(self):\n\t\treturn list(self._standards.keys())\n\n\t@property\n\tdef standard(self):\n\t\treturn self._current_standard_name\n\n\t@standard.setter\n\tdef standard(self, value):\n\t\tif value in self._standards:\n\t\t\tself._current_standard_name = value\n\t\t\tself._current_type_name = \"\"\n\t\t\tself._current_type = None\n\n\t@property\n\tdef types(self):\n\t\treturn self._standards[self._current_standard_name].keys()\n\n\tdef get_types_from_standard(self, standard):\n\t\tif standard in self._standards:\n\t\t\treturn list(self._standards[standard].keys())\n\t\treturn []\n\n\tdef make_type(self, standard_name, type_name):\n\t\tif standard_name not in self._standards:\n\t\t\tstandard = {}\n\t\t\tself._standards[standard_name] = standard\n\t\telse:\n\t\t\tstandard = self._standards[standard_name]\n\t\ttype = {}\n\t\tstandard[type_name] = type\n\t\treturn type\n\n\t@property\n\tdef type(self):\n\t\treturn self._current_type_name\n\n\t@type.setter\n\tdef type(self, type_name):\n\t\tif type_name in self._standards[self._current_standard_name]:\n\t\t\tself._current_type = self._standards[self._current_standard_name][type_name]\n\t\t\tself._current_type_name = type_name\n\t\t\tif self._current_type is None:\n\t\t\t\treturn\n\t\t\tfor param_definition_tuple in self._current_type.items():\n\t\t\t\tuid = param_definition_tuple[0]\n\t\t\t\tval = param_definition_tuple[1]\n\t\t\t\tif uid in self._params:\n\t\t\t\t\tparam = self._params[uid]\n\t\t\t\t\told_value = param.value\n\t\t\t\t\tparam.internal_formula = val['if']\n\t\t\t\t\tparam.internal_value = param.evaluate(None)\n\t\t\t\t\tchange_object = {\n\t\t\t\t\t\t'new value': param.value,\n\t\t\t\t\t\t'old value': old_value,\n\t\t\t\t\t\t'instance': None\n\t\t\t\t\t}\n\t\t\t\t\tparam.changed(ChangeEvent(param, ChangeEvent.ValueChanged, change_object))\n\t\t\tself.changed(ChangeEvent(self, ChangeEvent.ObjectChanged, self))\n\n\tdef _add_parameter_object(self, param):\n\t\tparam.add_change_handler(self.on_parameter_changed)\n\t\tself.changed(ChangeEvent(self, ChangeEvent.BeforeObjectAdded, param))\n\t\tself._params[param.uid] = param\n\t\tself._parameter_list.append(param.uid)\n\t\tself.changed(ChangeEvent(self, ChangeEvent.ObjectAdded, param))\n\n\tdef _remove_parameter_object(self, uid):\n\t\tif uid in self._params:\n\t\t\tself._params.pop(uid)\n\n\tdef get_parameter_by_uid(self, uid) -> Parameter:\n\t\tif uid in self._params:\n\t\t\treturn self._params[uid]\n\t\telif self._parent is not None:\n\t\t\treturn self._parent.get_parameter_by_uid(uid)\n\t\telse:\n\t\t\treturn None\n\n\tdef get_parameter_by_name(self, name) -> Parameter:\n\t\tparam = None\n\t\tfor prm in self._params.values():\n\t\t\tif prm.name == name:\n\t\t\t\tparam = prm\n\t\tif param is None and self._custom_name_getter is not None:\n\t\t\tparam = self._custom_name_getter(name)\n\t\tif param is None and self._parent is not None:\n\t\t\tparam = self._parent.get_parameter_by_name(name)\n\n\t\treturn param\n\n\tdef get_all_local_parameters(self):\n\t\tparams = list(self._params.items())\n\t\treturn params\n\n\tdef get_all_parameters(self):\n\t\tparams = list(self._params.values())\n\t\tif self._parent is not None:\n\t\t\tparams.extend(self._parent.get_all_parameters())\n\t\treturn params\n\n\tdef create_parameter(self, name=None, value=0.0):\n\t\tif name is None:\n\t\t\tif self._parent is None:\n\t\t\t\tname = \"Global\" + str(len(self._parameter_list))\n\t\t\telse:\n\t\t\t\tname = self.name + str(len(self._parameter_list))\n\t\tparam = Parameter(self, name, value)\n\t\tself._add_parameter_object(param)\n\t\treturn param\n\n\tdef delete_parameter(self, uid):\n\t\tparam = self.get_parameter_by_uid(uid)\n\t\tif param is not None:\n\t\t\tparam.remove_change_handler(self.on_parameter_changed)\n\t\t\tself.changed(ChangeEvent(self, ChangeEvent.BeforeObjectRemoved, param))\n\t\t\tself._parameter_list.remove(uid)\n\t\t\tself.changed(ChangeEvent(self, ChangeEvent.ObjectRemoved, param))\n\t\t\tself._remove_parameter_object(uid)\n\t\t\tparam.changed(ChangeEvent(param, ChangeEvent.Deleted, param))\n\n\tdef delete_parameters(self, params):\n\t\tfor param in params:\n\t\t\tif param.uid in self._parameter_list:\n\t\t\t\tself.delete_parameter(param.uid)\n\n\tdef on_parameter_changed(self, event):\n\t\tparam = event.sender\n\t\tself.changed(ChangeEvent(self, event.type, event.sender))\n\t\tif self._current_type is not None and param.uid in self._params:\n\t\t\tif 'instance' in event.object and 'new formula' in event.object:\n\t\t\t\tif event.object['instance'] is None and event.object['new formula'] != event.object['old formula']:\n\n\t\t\t\t\tif param.uid in self._current_type:\n\t\t\t\t\t\tpredef = self._current_type[param.uid]\n\t\t\t\t\telse:\n\t\t\t\t\t\tpredef = {}\n\t\t\t\t\t\tself._current_type[param.uid] = predef\n\t\t\t\t\tpredef['if'] = param.internal_formula\n\t\t\t\t\tpredef['iv'] = param.internal_value\n\n\tdef get_index_of(self, parameter):\n\t\tif parameter.uid in self._parameter_list:\n\t\t\treturn self._parameter_list.index(parameter.uid)\n\t\telse:\n\t\t\treturn -1\n\n\t@property\n\tdef length(self):\n\t\treturn len(self._parameter_list)\n\n\t@property\n\tdef length_all(self):\n\t\tif self._parent is not None:\n\t\t\treturn self._parent.length_all + self.length\n\t\telse:\n\t\t\treturn self.length\n\n\tdef get_parameter_item(self, index):\n\t\tif index >= self.length:\n\t\t\treturn self._parent.get_parameter_item(index - self.length)\n\t\telse:\n\t\t\tuid = self._parameter_list[index]\n\t\tparam = self.get_parameter_by_uid(uid)\n\t\treturn param\n\n\tdef serialize_json(self):\n\t\treturn {\n\t\t\t'name': self._name,\n\t\t\t'params': self._params,\n\t\t\t'parameter_list': self._parameter_list,\n\t\t\t'pps': self._standards,\n\t\t\t'csn': self._current_standard_name,\n\t\t\t'ctn': self._current_type_name\n\t\t}\n\n\t@staticmethod\n\tdef deserialize(data, parent):\n\t\tparam = Parameters(parent)\n\t\tparam.deserialize_data(data)\n\t\treturn param\n\n\tdef deserialize_data(self, data):\n\t\tself._parameter_list = data.get('parameter_list', [])\n\t\tself._name = data.get('name', 'name missing')\n\t\tself._standards = data.get('pps', self._standards)\n\t\tself._current_standard_name = data.get(\"csn\", self._current_standard_name)\n\t\tself._current_type_name = data.get(\"ctn\", self._current_type_name)\n\t\tself._current_type = self._standards[self._current_standard_name][self._current_type_name]\n\t\tfor param_data in data.get('params', {}).items():\n\t\t\tparam = Parameter.deserialize(param_data[1], self)\n\t\t\tself._params[param.uid] = param\n\t\t\tparam.add_change_handler(self.on_parameter_changed)\n\n\t\tfor param_tuple in self._params.items():\n\t\t\tif param_tuple[1].formula != '':\n\t\t\t\ttry:\n\t\t\t\t\tparam_tuple[1].value = param_tuple[1].formula\n\t\t\t\texcept Exception as e:\n\t\t\t\t\tpass\nBusiness/ParameterActions.py\ndef remove_type(parameters_object: Parameters, standard_name, type_name):\n\tparameters_object.remove_type(standard_name, type_name)\nBusiness/ParameterActions.py\ndef create_new_type(parameters_object: Parameters, standard_name, type_name):\n\tparameters_object.make_type(standard_name, type_name)\n", "answers": ["\t\tself._caption_label.setMinimumWidth(100*gui_scale())"], "length": 2012, "dataset": "repobench-p_e", "language": "python", "all_classes": null, "_id": "4d2668d05f3f636a1bb6b0389a03b382f3f3e06b19dec51d", "pred": "```\nself.layout().addWidget(self._caption_label, row, 0)\n```\nPlease complete the code. I have provided the necessary parts of the code. The code is a part of a GUI application written in PyQt5. The code is supposed to create a dialog with a combo box and a table widget."}
{"prompt": "Please complete the code given below. \nmutagen/id3/_frames.py\ndef _bytes2key(b):\n    def __init__(self, *args, **kwargs):\n    def __setattr__(self, name, value):\n    def _setattr(self, name, value):\n    def _to_other(self, other):\n    def _merge_frame(self, other):\n    def _upgrade_frame(self):\n    def _get_v23_frame(self, **kwargs):\n    def HashKey(self):\n    def FrameID(self):\n    def __repr__(self):\n    def _readData(self, id3, data):\n    def _writeData(self, config=None):\n    def pprint(self):\n    def _pprint(self):\n    def _fromData(cls, header, tflags, data):\n    def __hash__(self: object):\n    def HashKey(self):\n    def __eq__(self, other):\n    def _pprint(self):\n    def HashKey(self):\n    def __eq__(self, other):\n    def _pprint(self):\n    def __bytes__(self):\n    def __str__(self):\n    def __eq__(self, other):\n    def __getitem__(self, item):\n    def __iter__(self):\n    def append(self, value):\n    def extend(self, value):\n    def _merge_frame(self, other):\n    def _pprint(self):\n    def __pos__(self):\n    def __pos__(self):\n    def __bytes__(self):\n    def __str__(self):\n    def _pprint(self):\n    def __bytes__(self):\n    def __str__(self):\n    def __eq__(self, other):\n    def _pprint(self):\n    def HashKey(self):\n    def __get_genres(self):\n    def __set_genres(self, genres):\n    def __decode(self, value):\n    def _pprint(self):\n    def HashKey(self):\n    def _pprint(self):\n    def HashKey(self):\n    def __eq__(self, other):\n    def __eq__(self, other):\n    def __eq__(self, other):\n    def __eq__(self, other):\n    def __eq__(self, other):\n    def HashKey(self):\n    def __bytes__(self):\n    def __str__(self):\n    def __eq__(self, other):\n    def _pprint(self):\n    def HashKey(self):\n    def _pprint(self):\n    def __eq__(self, other):\n    def __str__(self):\n    def __bytes__(self):\n    def HashKey(self):\n    def _pprint(self):\n    def HashKey(self):\n    def __eq__(self, other):\n    def __str__(self):\n    def __eq__(self, other):\n    def HashKey(self):\n    def __eq__(self, other):\n    def __eq__(self, other):\n    def __eq__(self, other):\n    def HashKey(self):\n    def _merge_frame(self, other):\n    def _pprint(self):\n    def __eq__(self, other):\n    def __pos__(self):\n    def _pprint(self):\n    def __eq__(self, other):\n    def __pos__(self):\n    def _pprint(self):\n    def HashKey(self):\n    def __eq__(self, other):\n    def __pos__(self):\n    def _pprint(self):\n    def HashKey(self):\n    def __eq__(self, other):\n    def __eq__(self, other):\n    def __pos__(self):\n    def HashKey(self):\n    def __bytes__(self):\n    def __str__(self):\n    def __eq__(self, other):\n    def HashKey(self):\n    def __eq__(self, other):\n    def __pos__(self):\n    def __eq__(self, other):\n    def HashKey(self):\n    def __eq__(s, o):\n    def _pprint(self):\n    def HashKey(self):\n    def __bytes__(self):\n    def __str__(self):\n    def __eq__(self, other):\n    def _pprint(self):\n    def __bytes__(self):\n    def __str__(self):\n    def __eq__(self, other):\n    def HashKey(self):\n    def __eq__(self, other):\n    def HashKey(self):\n    def __bytes__(self):\n    def __eq__(self, other):\n    def HashKey(self):\n    def __pos__(self):\n    def __bytes__(self):\n    def __str__(self):\n    def __eq__(self, other):\n    def HashKey(self):\n    def __bytes__(self):\n    def __eq__(self, other):\n    def _pprint(self):\n    def HashKey(self):\n    def __bytes__(self):\n    def __eq__(self, other):\n    def __pos__(self):\n    def __eq__(self, other):\n    def __eq__(self, other):\n    def _to_other(self, other):\n    def _to_other(self, other):\n    def __eq__(self, other):\n    def _to_other(self, other):\nclass Frame(object):\nclass CHAP(Frame):\nclass CTOC(Frame):\nclass TextFrame(Frame):\nclass NumericTextFrame(TextFrame):\nclass NumericPartTextFrame(TextFrame):\nclass TimeStampTextFrame(TextFrame):\nclass UrlFrame(Frame):\nclass UrlFrameU(UrlFrame):\nclass TALB(TextFrame):\nclass TBPM(NumericTextFrame):\nclass TCOM(TextFrame):\nclass TCON(TextFrame):\nclass TCOP(TextFrame):\nclass TCMP(NumericTextFrame):\nclass TDAT(TextFrame):\nclass TDEN(TimeStampTextFrame):\nclass TDES(TextFrame):\nclass TKWD(TextFrame):\nclass TCAT(TextFrame):\nclass MVNM(TextFrame):\nclass MVN(MVNM):\nclass MVIN(NumericPartTextFrame):\nclass MVI(MVIN):\nclass GRP1(TextFrame):\nclass GP1(GRP1):\nclass TDOR(TimeStampTextFrame):\nclass TDLY(NumericTextFrame):\nclass TDRC(TimeStampTextFrame):\nclass TDRL(TimeStampTextFrame):\nclass TDTG(TimeStampTextFrame):\nclass TENC(TextFrame):\nclass TEXT(TextFrame):\nclass TFLT(TextFrame):\nclass TGID(TextFrame):\nclass TIME(TextFrame):\nclass TIT1(TextFrame):\nclass TIT2(TextFrame):\nclass TIT3(TextFrame):\nclass TKEY(TextFrame):\nclass TLAN(TextFrame):\nclass TLEN(NumericTextFrame):\nclass TMED(TextFrame):\nclass TMOO(TextFrame):\nclass TOAL(TextFrame):\nclass TOFN(TextFrame):\nclass TOLY(TextFrame):\nclass TOPE(TextFrame):\nclass TORY(NumericTextFrame):\nclass TOWN(TextFrame):\nclass TPE1(TextFrame):\nclass TPE2(TextFrame):\nclass TPE3(TextFrame):\nclass TPE4(TextFrame):\nclass TPOS(NumericPartTextFrame):\nclass TPRO(TextFrame):\nclass TPUB(TextFrame):\nclass TRCK(NumericPartTextFrame):\nclass TRDA(TextFrame):\nclass TRSN(TextFrame):\nclass TRSO(TextFrame):\nclass TSIZ(NumericTextFrame):\nclass TSO2(TextFrame):\nclass TSOA(TextFrame):\nclass TSOC(TextFrame):\nclass TSOP(TextFrame):\nclass TSOT(TextFrame):\nclass TSRC(TextFrame):\nclass TSSE(TextFrame):\nclass TSST(TextFrame):\nclass TYER(NumericTextFrame):\nclass TXXX(TextFrame):\nclass WCOM(UrlFrameU):\nclass WCOP(UrlFrame):\nclass WFED(UrlFrame):\nclass WOAF(UrlFrame):\nclass WOAR(UrlFrameU):\nclass WOAS(UrlFrame):\nclass WORS(UrlFrame):\nclass WPAY(UrlFrame):\nclass WPUB(UrlFrame):\nclass WXXX(UrlFrame):\nclass PairedTextFrame(Frame):\nclass TIPL(PairedTextFrame):\nclass TMCL(PairedTextFrame):\nclass IPLS(TIPL):\nclass BinaryFrame(Frame):\nclass MCDI(BinaryFrame):\nclass ETCO(Frame):\nclass MLLT(Frame):\nclass SYTC(Frame):\nclass USLT(Frame):\nclass SYLT(Frame):\nclass COMM(TextFrame):\nclass RVA2(Frame):\nclass EQU2(Frame):\nclass RVAD(Frame):\nclass RVRB(Frame):\nclass APIC(Frame):\nclass PCNT(Frame):\nclass PCST(Frame):\nclass POPM(Frame):\nclass GEOB(Frame):\nclass RBUF(Frame):\nclass AENC(Frame):\nclass LINK(Frame):\nclass POSS(Frame):\nclass UFID(Frame):\nclass USER(Frame):\nclass OWNE(Frame):\nclass COMR(Frame):\nclass ENCR(Frame):\nclass GRID(Frame):\nclass PRIV(Frame):\nclass SIGN(Frame):\nclass SEEK(Frame):\nclass ASPI(Frame):\nclass UFI(UFID):\nclass TT1(TIT1):\nclass TT2(TIT2):\nclass TT3(TIT3):\nclass TP1(TPE1):\nclass TP2(TPE2):\nclass TP3(TPE3):\nclass TP4(TPE4):\nclass TCM(TCOM):\nclass TXT(TEXT):\nclass TLA(TLAN):\nclass TCO(TCON):\nclass TAL(TALB):\nclass TPA(TPOS):\nclass TRK(TRCK):\nclass TRC(TSRC):\nclass TYE(TYER):\nclass TDA(TDAT):\nclass TIM(TIME):\nclass TRD(TRDA):\nclass TMT(TMED):\nclass TFT(TFLT):\nclass TBP(TBPM):\nclass TCP(TCMP):\nclass TCR(TCOP):\nclass TPB(TPUB):\nclass TEN(TENC):\nclass TST(TSOT):\nclass TSA(TSOA):\nclass TS2(TSO2):\nclass TSP(TSOP):\nclass TSC(TSOC):\nclass TSS(TSSE):\nclass TOF(TOFN):\nclass TLE(TLEN):\nclass TSI(TSIZ):\nclass TDY(TDLY):\nclass TKE(TKEY):\nclass TOT(TOAL):\nclass TOA(TOPE):\nclass TOL(TOLY):\nclass TOR(TORY):\nclass TXX(TXXX):\nclass WAF(WOAF):\nclass WAR(WOAR):\nclass WAS(WOAS):\nclass WCM(WCOM):\nclass WCP(WCOP):\nclass WPB(WPUB):\nclass WXX(WXXX):\nclass IPL(IPLS):\nclass MCI(MCDI):\nclass ETC(ETCO):\nclass MLL(MLLT):\nclass STC(SYTC):\nclass ULT(USLT):\nclass SLT(SYLT):\nclass COM(COMM):\nclass RVA(RVAD):\nclass REV(RVRB):\nclass PIC(APIC):\nclass GEO(GEOB):\nclass CNT(PCNT):\nclass POP(POPM):\nclass BUF(RBUF):\nclass CRM(Frame):\nclass CRA(AENC):\nclass LNK(LINK):\n    FLAG23_ALTERTAG = 0x8000\n    FLAG23_ALTERFILE = 0x4000\n    FLAG23_READONLY = 0x2000\n    FLAG23_COMPRESS = 0x0080\n    FLAG23_ENCRYPT = 0x0040\n    FLAG23_GROUP = 0x0020\n    FLAG24_ALTERTAG = 0x4000\n    FLAG24_ALTERFILE = 0x2000\n    FLAG24_READONLY = 0x1000\n    FLAG24_GROUPID = 0x0040\n    FLAG24_COMPRESS = 0x0008\n    FLAG24_ENCRYPT = 0x0004\n    FLAG24_UNSYNCH = 0x0002\n    FLAG24_DATALEN = 0x0001\n    GENRES = GENRES\nmutagen/_util.py\ndef read_full(fileobj, size):\n    \"\"\"Like fileobj.read but raises IOError if not all requested data is\n    returned.\n\n    If you want to distinguish IOError and the EOS case, better handle\n    the error yourself instead of using this.\n\n    Args:\n        fileobj (fileobj)\n        size (int): amount of bytes to read\n    Raises:\n        IOError: In case read fails or not enough data is read\n    \"\"\"\n\n    if size < 0:\n        raise ValueError(\"size must not be negative\")\n\n    data = fileobj.read(size)\n    if len(data) != size:\n        raise IOError\n    return data\nmutagen/id3/_util.py\nclass error(MutagenError):\n    pass\nmutagen/id3/_util.py\nclass ID3UnsupportedVersionError(error, NotImplementedError):\n    pass\nmutagen/id3/_util.py\ndef is_valid_frame_id(frame_id):\n    return frame_id.isalnum() and frame_id.isupper()\nmutagen/id3/_util.py\nclass ID3NoHeaderError(error, ValueError):\n    pass\nmutagen/_util.py\nclass DictProxy(DictMixin):\n    def __init__(self, *args, **kwargs):\n        self.__dict = {}\n        super(DictProxy, self).__init__(*args, **kwargs)\n\n    def __getitem__(self, key):\n        return self.__dict[key]\n\n    def __setitem__(self, key, value):\n        self.__dict[key] = value\n\n    def __delitem__(self, key):\n        del(self.__dict[key])\n\n    def keys(self):\n        return self.__dict.keys()\nmutagen/id3/_util.py\nclass BitPaddedInt(int, _BitPaddedMixin):\n\n    def __new__(cls, value, bits=7, bigendian=True):\n\n        mask = (1 << (bits)) - 1\n        numeric_value = 0\n        shift = 0\n\n        if isinstance(value, int):\n            if value < 0:\n                raise ValueError\n            while value:\n                numeric_value += (value & mask) << shift\n                value >>= 8\n                shift += bits\n        elif isinstance(value, bytes):\n            if bigendian:\n                value = reversed(value)\n            for byte in bytearray(value):\n                numeric_value += (byte & mask) << shift\n                shift += bits\n        else:\n            raise TypeError\n\n        self = int.__new__(BitPaddedInt, numeric_value)\n\n        self.bits = bits\n        self.bigendian = bigendian\n        return self\nmutagen/_util.py\ndef convert_error(exc_src, exc_dest):\n    \"\"\"A decorator for reraising exceptions with a different type.\n    Mostly useful for IOError.\n\n    Args:\n        exc_src (type): The source exception type\n        exc_dest (type): The target exception type.\n    \"\"\"\n\n    def wrap(func):\n\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            try:\n                return func(*args, **kwargs)\n            except exc_dest:\n                raise\n            except exc_src as err:\n                reraise(exc_dest, err, sys.exc_info()[2])\n\n        return wrapper\n\n    return wrap\nmutagen/_tags.py\nclass Tags(object):\n    \"\"\"`Tags` is the base class for many of the tag objects in Mutagen.\n\n    In many cases it has a dict like interface.\n    \"\"\"\n\n    __module__ = \"mutagen\"\n\n    def pprint(self):\n        \"\"\"\n        Returns:\n            text: tag information\n        \"\"\"\n\n        raise NotImplementedError\nmutagen/id3/_util.py\nclass ID3EncryptionUnsupportedError(error, NotImplementedError):\n    pass\nmutagen/id3/_util.py\nclass ID3JunkFrameError(error):\n    pass\nmutagen/id3/_util.py\nclass ID3SaveConfig(object):\n\n    def __init__(self, v2_version=4, v23_separator=None):\n        assert v2_version in (3, 4)\n        self.v2_version = v2_version\n        self.v23_separator = v23_separator\nmutagen/id3/_util.py\nclass unsynch(object):\n    @staticmethod\n    def decode(value):\n        fragments = bytearray(value).split(b'\\xff')\n        if len(fragments) > 1 and not fragments[-1]:\n            raise ValueError('string ended unsafe')\n\n        for f in fragments[1:]:\n            if (not f) or (f[0] >= 0xE0):\n                raise ValueError('invalid sync-safe string')\n\n            if f[0] == 0x00:\n                del f[0]\n\n        return bytes(bytearray(b'\\xff').join(fragments))\n\n    @staticmethod\n    def encode(value):\n        fragments = bytearray(value).split(b'\\xff')\n        for f in fragments[1:]:\n            if (not f) or (f[0] >= 0xE0) or (f[0] == 0x00):\n                f.insert(0, 0x00)\n        return bytes(bytearray(b'\\xff').join(fragments))\nimport re\nimport struct\nfrom itertools import zip_longest\nfrom mutagen._tags import Tags\nfrom mutagen._util import DictProxy, convert_error, read_full\nfrom ._util import BitPaddedInt, unsynch, ID3JunkFrameError, \\\n    ID3EncryptionUnsupportedError, is_valid_frame_id, error, \\\n    ID3NoHeaderError, ID3UnsupportedVersionError, ID3SaveConfig\nfrom ._frames import TDRC, APIC, TDOR, TIME, TIPL, TORY, TDAT, Frames_2_2, \\\n    TextFrame, TYER, Frame, IPLS, Frames\n                timestamps.append(timestamp)\n        if timestamps and \"TDRC\" not in self:\n            self.add(TDRC(encoding=0, text=timestamps))\n\n        # TORY can be the first part of a TDOR.\n        if \"TORY\" in self:\n            f = self.pop(\"TORY\")\n            if \"TDOR\" not in self:\n                try:\n                    self.add(TDOR(encoding=0, text=str(f)))\n                except UnicodeDecodeError:\n                    pass\n\n        # IPLS is now TIPL.\n        if \"IPLS\" in self:\n            f = self.pop(\"IPLS\")\n            if \"TIPL\" not in self:\n                self.add(TIPL(encoding=f.encoding, people=f.people))\n\n        # These can't be trivially translated to any ID3v2.4 tags, or\n        # should have been removed already.\n        for key in [\"RVAD\", \"EQUA\", \"TRDA\", \"TSIZ\", \"TDAT\", \"TIME\"]:\n            if key in self:\n                del(self[key])\n\n        # Recurse into chapters\n        for f in self.getall(\"CHAP\"):\n            f.sub_frames.update_to_v24()\n        for f in self.getall(\"CTOC\"):\n            f.sub_frames.update_to_v24()\n\n    def update_to_v23(self):\n        \"\"\"Convert older (and newer) tags into an ID3v2.3 tag.\n\n        This updates incompatible ID3v2 frames to ID3v2.3 ones. If you\n        intend to save tags as ID3v2.3, you must call this function\n        at some point.\n\n        If you want to to go off spec and include some v2.4 frames\n        in v2.3, remove them before calling this and add them back afterwards.\n        \"\"\"\n\n        self.__update_common()\n\n        # TMCL, TIPL -> TIPL\n        if \"TIPL\" in self or \"TMCL\" in self:\n            people = []\n            if \"TIPL\" in self:\n                f = self.pop(\"TIPL\")\n                people.extend(f.people)\n            if \"TMCL\" in self:\n                f = self.pop(\"TMCL\")\n                people.extend(f.people)\n            if \"IPLS\" not in self:\n                self.add(IPLS(encoding=f.encoding, people=people))\n\n        # TDOR -> TORY\n        if \"TDOR\" in self:\n            f = self.pop(\"TDOR\")\n            if f.text:\n                d = f.text[0]\n                if d.year and \"TORY\" not in self:\n                    self.add(TORY(encoding=f.encoding, text=\"%04d\" % d.year))\n\n        # TDRC -> TYER, TDAT, TIME\n        if \"TDRC\" in self:\n            f = self.pop(\"TDRC\")\n            if f.text:\n                d = f.text[0]\n                if d.year and \"TYER\" not in self:\n                    self.add(TYER(encoding=f.encoding, text=\"%04d\" % d.year))\n                if d.month and d.day and \"TDAT\" not in self:\n                    self.add(TDAT(encoding=f.encoding,\n                                  text=\"%02d%02d\" % (d.day, d.month)))\n                if d.hour and d.minute and \"TIME\" not in self:\n                    self.add(TIME(encoding=f.encoding,\n                                  text=\"%02d%02d\" % (d.hour, d.minute)))\n\n        # New frames added in v2.4\n        v24_frames = [\n            'ASPI', 'EQU2', 'RVA2', 'SEEK', 'SIGN', 'TDEN', 'TDOR',\n            'TDRC', 'TDRL', 'TDTG', 'TIPL', 'TMCL', 'TMOO', 'TPRO',\n            'TSOA', 'TSOP', 'TSOT', 'TSST',\n        ]\n\n        for key in v24_frames:\n            if key in self:\n                del(self[key])\n\n        # Recurse into chapters\n        for f in self.getall(\"CHAP\"):\n            f.sub_frames.update_to_v23()\n        for f in self.getall(\"CTOC\"):\n            f.sub_frames.update_to_v23()\n\n    def _copy(self):\n        \"\"\"Creates a shallow copy of all tags\"\"\"\n\n        items = self.items()\n        subs = {}\n        for f in (self.getall(\"CHAP\") + self.getall(\"CTOC\")):\n            subs[f.HashKey] = f.sub_frames._copy()\n        return (items, subs)\n\n    def _restore(self, value):\n        \"\"\"Restores the state copied with _copy()\"\"\"\n\n        items, subs = value\n        self.clear()\n        for key, value in items:\n            self[key] = value\n            if key in subs:\n                value.sub_frames._restore(subs[key])\n\n\ndef save_frame(frame, name=None, config=None):\n    if config is None:\n        config = ID3SaveConfig()\n\n    flags = 0\nNext line of code:\n", "input": "import re\nimport struct\nfrom itertools import zip_longest\nfrom mutagen._tags import Tags\nfrom mutagen._util import DictProxy, convert_error, read_full\nfrom ._util import BitPaddedInt, unsynch, ID3JunkFrameError, \\\n    ID3EncryptionUnsupportedError, is_valid_frame_id, error, \\\n    ID3NoHeaderError, ID3UnsupportedVersionError, ID3SaveConfig\nfrom ._frames import TDRC, APIC, TDOR, TIME, TIPL, TORY, TDAT, Frames_2_2, \\\n    TextFrame, TYER, Frame, IPLS, Frames\n                timestamps.append(timestamp)\n        if timestamps and \"TDRC\" not in self:\n            self.add(TDRC(encoding=0, text=timestamps))\n\n        # TORY can be the first part of a TDOR.\n        if \"TORY\" in self:\n            f = self.pop(\"TORY\")\n            if \"TDOR\" not in self:\n                try:\n                    self.add(TDOR(encoding=0, text=str(f)))\n                except UnicodeDecodeError:\n                    pass\n\n        # IPLS is now TIPL.\n        if \"IPLS\" in self:\n            f = self.pop(\"IPLS\")\n            if \"TIPL\" not in self:\n                self.add(TIPL(encoding=f.encoding, people=f.people))\n\n        # These can't be trivially translated to any ID3v2.4 tags, or\n        # should have been removed already.\n        for key in [\"RVAD\", \"EQUA\", \"TRDA\", \"TSIZ\", \"TDAT\", \"TIME\"]:\n            if key in self:\n                del(self[key])\n\n        # Recurse into chapters\n        for f in self.getall(\"CHAP\"):\n            f.sub_frames.update_to_v24()\n        for f in self.getall(\"CTOC\"):\n            f.sub_frames.update_to_v24()\n\n    def update_to_v23(self):\n        \"\"\"Convert older (and newer) tags into an ID3v2.3 tag.\n\n        This updates incompatible ID3v2 frames to ID3v2.3 ones. If you\n        intend to save tags as ID3v2.3, you must call this function\n        at some point.\n\n        If you want to to go off spec and include some v2.4 frames\n        in v2.3, remove them before calling this and add them back afterwards.\n        \"\"\"\n\n        self.__update_common()\n\n        # TMCL, TIPL -> TIPL\n        if \"TIPL\" in self or \"TMCL\" in self:\n            people = []\n            if \"TIPL\" in self:\n                f = self.pop(\"TIPL\")\n                people.extend(f.people)\n            if \"TMCL\" in self:\n                f = self.pop(\"TMCL\")\n                people.extend(f.people)\n            if \"IPLS\" not in self:\n                self.add(IPLS(encoding=f.encoding, people=people))\n\n        # TDOR -> TORY\n        if \"TDOR\" in self:\n            f = self.pop(\"TDOR\")\n            if f.text:\n                d = f.text[0]\n                if d.year and \"TORY\" not in self:\n                    self.add(TORY(encoding=f.encoding, text=\"%04d\" % d.year))\n\n        # TDRC -> TYER, TDAT, TIME\n        if \"TDRC\" in self:\n            f = self.pop(\"TDRC\")\n            if f.text:\n                d = f.text[0]\n                if d.year and \"TYER\" not in self:\n                    self.add(TYER(encoding=f.encoding, text=\"%04d\" % d.year))\n                if d.month and d.day and \"TDAT\" not in self:\n                    self.add(TDAT(encoding=f.encoding,\n                                  text=\"%02d%02d\" % (d.day, d.month)))\n                if d.hour and d.minute and \"TIME\" not in self:\n                    self.add(TIME(encoding=f.encoding,\n                                  text=\"%02d%02d\" % (d.hour, d.minute)))\n\n        # New frames added in v2.4\n        v24_frames = [\n            'ASPI', 'EQU2', 'RVA2', 'SEEK', 'SIGN', 'TDEN', 'TDOR',\n            'TDRC', 'TDRL', 'TDTG', 'TIPL', 'TMCL', 'TMOO', 'TPRO',\n            'TSOA', 'TSOP', 'TSOT', 'TSST',\n        ]\n\n        for key in v24_frames:\n            if key in self:\n                del(self[key])\n\n        # Recurse into chapters\n        for f in self.getall(\"CHAP\"):\n            f.sub_frames.update_to_v23()\n        for f in self.getall(\"CTOC\"):\n            f.sub_frames.update_to_v23()\n\n    def _copy(self):\n        \"\"\"Creates a shallow copy of all tags\"\"\"\n\n        items = self.items()\n        subs = {}\n        for f in (self.getall(\"CHAP\") + self.getall(\"CTOC\")):\n            subs[f.HashKey] = f.sub_frames._copy()\n        return (items, subs)\n\n    def _restore(self, value):\n        \"\"\"Restores the state copied with _copy()\"\"\"\n\n        items, subs = value\n        self.clear()\n        for key, value in items:\n            self[key] = value\n            if key in subs:\n                value.sub_frames._restore(subs[key])\n\n\ndef save_frame(frame, name=None, config=None):\n    if config is None:\n        config = ID3SaveConfig()\n\n    flags = 0\n", "context": "mutagen/id3/_frames.py\ndef _bytes2key(b):\n    def __init__(self, *args, **kwargs):\n    def __setattr__(self, name, value):\n    def _setattr(self, name, value):\n    def _to_other(self, other):\n    def _merge_frame(self, other):\n    def _upgrade_frame(self):\n    def _get_v23_frame(self, **kwargs):\n    def HashKey(self):\n    def FrameID(self):\n    def __repr__(self):\n    def _readData(self, id3, data):\n    def _writeData(self, config=None):\n    def pprint(self):\n    def _pprint(self):\n    def _fromData(cls, header, tflags, data):\n    def __hash__(self: object):\n    def HashKey(self):\n    def __eq__(self, other):\n    def _pprint(self):\n    def HashKey(self):\n    def __eq__(self, other):\n    def _pprint(self):\n    def __bytes__(self):\n    def __str__(self):\n    def __eq__(self, other):\n    def __getitem__(self, item):\n    def __iter__(self):\n    def append(self, value):\n    def extend(self, value):\n    def _merge_frame(self, other):\n    def _pprint(self):\n    def __pos__(self):\n    def __pos__(self):\n    def __bytes__(self):\n    def __str__(self):\n    def _pprint(self):\n    def __bytes__(self):\n    def __str__(self):\n    def __eq__(self, other):\n    def _pprint(self):\n    def HashKey(self):\n    def __get_genres(self):\n    def __set_genres(self, genres):\n    def __decode(self, value):\n    def _pprint(self):\n    def HashKey(self):\n    def _pprint(self):\n    def HashKey(self):\n    def __eq__(self, other):\n    def __eq__(self, other):\n    def __eq__(self, other):\n    def __eq__(self, other):\n    def __eq__(self, other):\n    def HashKey(self):\n    def __bytes__(self):\n    def __str__(self):\n    def __eq__(self, other):\n    def _pprint(self):\n    def HashKey(self):\n    def _pprint(self):\n    def __eq__(self, other):\n    def __str__(self):\n    def __bytes__(self):\n    def HashKey(self):\n    def _pprint(self):\n    def HashKey(self):\n    def __eq__(self, other):\n    def __str__(self):\n    def __eq__(self, other):\n    def HashKey(self):\n    def __eq__(self, other):\n    def __eq__(self, other):\n    def __eq__(self, other):\n    def HashKey(self):\n    def _merge_frame(self, other):\n    def _pprint(self):\n    def __eq__(self, other):\n    def __pos__(self):\n    def _pprint(self):\n    def __eq__(self, other):\n    def __pos__(self):\n    def _pprint(self):\n    def HashKey(self):\n    def __eq__(self, other):\n    def __pos__(self):\n    def _pprint(self):\n    def HashKey(self):\n    def __eq__(self, other):\n    def __eq__(self, other):\n    def __pos__(self):\n    def HashKey(self):\n    def __bytes__(self):\n    def __str__(self):\n    def __eq__(self, other):\n    def HashKey(self):\n    def __eq__(self, other):\n    def __pos__(self):\n    def __eq__(self, other):\n    def HashKey(self):\n    def __eq__(s, o):\n    def _pprint(self):\n    def HashKey(self):\n    def __bytes__(self):\n    def __str__(self):\n    def __eq__(self, other):\n    def _pprint(self):\n    def __bytes__(self):\n    def __str__(self):\n    def __eq__(self, other):\n    def HashKey(self):\n    def __eq__(self, other):\n    def HashKey(self):\n    def __bytes__(self):\n    def __eq__(self, other):\n    def HashKey(self):\n    def __pos__(self):\n    def __bytes__(self):\n    def __str__(self):\n    def __eq__(self, other):\n    def HashKey(self):\n    def __bytes__(self):\n    def __eq__(self, other):\n    def _pprint(self):\n    def HashKey(self):\n    def __bytes__(self):\n    def __eq__(self, other):\n    def __pos__(self):\n    def __eq__(self, other):\n    def __eq__(self, other):\n    def _to_other(self, other):\n    def _to_other(self, other):\n    def __eq__(self, other):\n    def _to_other(self, other):\nclass Frame(object):\nclass CHAP(Frame):\nclass CTOC(Frame):\nclass TextFrame(Frame):\nclass NumericTextFrame(TextFrame):\nclass NumericPartTextFrame(TextFrame):\nclass TimeStampTextFrame(TextFrame):\nclass UrlFrame(Frame):\nclass UrlFrameU(UrlFrame):\nclass TALB(TextFrame):\nclass TBPM(NumericTextFrame):\nclass TCOM(TextFrame):\nclass TCON(TextFrame):\nclass TCOP(TextFrame):\nclass TCMP(NumericTextFrame):\nclass TDAT(TextFrame):\nclass TDEN(TimeStampTextFrame):\nclass TDES(TextFrame):\nclass TKWD(TextFrame):\nclass TCAT(TextFrame):\nclass MVNM(TextFrame):\nclass MVN(MVNM):\nclass MVIN(NumericPartTextFrame):\nclass MVI(MVIN):\nclass GRP1(TextFrame):\nclass GP1(GRP1):\nclass TDOR(TimeStampTextFrame):\nclass TDLY(NumericTextFrame):\nclass TDRC(TimeStampTextFrame):\nclass TDRL(TimeStampTextFrame):\nclass TDTG(TimeStampTextFrame):\nclass TENC(TextFrame):\nclass TEXT(TextFrame):\nclass TFLT(TextFrame):\nclass TGID(TextFrame):\nclass TIME(TextFrame):\nclass TIT1(TextFrame):\nclass TIT2(TextFrame):\nclass TIT3(TextFrame):\nclass TKEY(TextFrame):\nclass TLAN(TextFrame):\nclass TLEN(NumericTextFrame):\nclass TMED(TextFrame):\nclass TMOO(TextFrame):\nclass TOAL(TextFrame):\nclass TOFN(TextFrame):\nclass TOLY(TextFrame):\nclass TOPE(TextFrame):\nclass TORY(NumericTextFrame):\nclass TOWN(TextFrame):\nclass TPE1(TextFrame):\nclass TPE2(TextFrame):\nclass TPE3(TextFrame):\nclass TPE4(TextFrame):\nclass TPOS(NumericPartTextFrame):\nclass TPRO(TextFrame):\nclass TPUB(TextFrame):\nclass TRCK(NumericPartTextFrame):\nclass TRDA(TextFrame):\nclass TRSN(TextFrame):\nclass TRSO(TextFrame):\nclass TSIZ(NumericTextFrame):\nclass TSO2(TextFrame):\nclass TSOA(TextFrame):\nclass TSOC(TextFrame):\nclass TSOP(TextFrame):\nclass TSOT(TextFrame):\nclass TSRC(TextFrame):\nclass TSSE(TextFrame):\nclass TSST(TextFrame):\nclass TYER(NumericTextFrame):\nclass TXXX(TextFrame):\nclass WCOM(UrlFrameU):\nclass WCOP(UrlFrame):\nclass WFED(UrlFrame):\nclass WOAF(UrlFrame):\nclass WOAR(UrlFrameU):\nclass WOAS(UrlFrame):\nclass WORS(UrlFrame):\nclass WPAY(UrlFrame):\nclass WPUB(UrlFrame):\nclass WXXX(UrlFrame):\nclass PairedTextFrame(Frame):\nclass TIPL(PairedTextFrame):\nclass TMCL(PairedTextFrame):\nclass IPLS(TIPL):\nclass BinaryFrame(Frame):\nclass MCDI(BinaryFrame):\nclass ETCO(Frame):\nclass MLLT(Frame):\nclass SYTC(Frame):\nclass USLT(Frame):\nclass SYLT(Frame):\nclass COMM(TextFrame):\nclass RVA2(Frame):\nclass EQU2(Frame):\nclass RVAD(Frame):\nclass RVRB(Frame):\nclass APIC(Frame):\nclass PCNT(Frame):\nclass PCST(Frame):\nclass POPM(Frame):\nclass GEOB(Frame):\nclass RBUF(Frame):\nclass AENC(Frame):\nclass LINK(Frame):\nclass POSS(Frame):\nclass UFID(Frame):\nclass USER(Frame):\nclass OWNE(Frame):\nclass COMR(Frame):\nclass ENCR(Frame):\nclass GRID(Frame):\nclass PRIV(Frame):\nclass SIGN(Frame):\nclass SEEK(Frame):\nclass ASPI(Frame):\nclass UFI(UFID):\nclass TT1(TIT1):\nclass TT2(TIT2):\nclass TT3(TIT3):\nclass TP1(TPE1):\nclass TP2(TPE2):\nclass TP3(TPE3):\nclass TP4(TPE4):\nclass TCM(TCOM):\nclass TXT(TEXT):\nclass TLA(TLAN):\nclass TCO(TCON):\nclass TAL(TALB):\nclass TPA(TPOS):\nclass TRK(TRCK):\nclass TRC(TSRC):\nclass TYE(TYER):\nclass TDA(TDAT):\nclass TIM(TIME):\nclass TRD(TRDA):\nclass TMT(TMED):\nclass TFT(TFLT):\nclass TBP(TBPM):\nclass TCP(TCMP):\nclass TCR(TCOP):\nclass TPB(TPUB):\nclass TEN(TENC):\nclass TST(TSOT):\nclass TSA(TSOA):\nclass TS2(TSO2):\nclass TSP(TSOP):\nclass TSC(TSOC):\nclass TSS(TSSE):\nclass TOF(TOFN):\nclass TLE(TLEN):\nclass TSI(TSIZ):\nclass TDY(TDLY):\nclass TKE(TKEY):\nclass TOT(TOAL):\nclass TOA(TOPE):\nclass TOL(TOLY):\nclass TOR(TORY):\nclass TXX(TXXX):\nclass WAF(WOAF):\nclass WAR(WOAR):\nclass WAS(WOAS):\nclass WCM(WCOM):\nclass WCP(WCOP):\nclass WPB(WPUB):\nclass WXX(WXXX):\nclass IPL(IPLS):\nclass MCI(MCDI):\nclass ETC(ETCO):\nclass MLL(MLLT):\nclass STC(SYTC):\nclass ULT(USLT):\nclass SLT(SYLT):\nclass COM(COMM):\nclass RVA(RVAD):\nclass REV(RVRB):\nclass PIC(APIC):\nclass GEO(GEOB):\nclass CNT(PCNT):\nclass POP(POPM):\nclass BUF(RBUF):\nclass CRM(Frame):\nclass CRA(AENC):\nclass LNK(LINK):\n    FLAG23_ALTERTAG = 0x8000\n    FLAG23_ALTERFILE = 0x4000\n    FLAG23_READONLY = 0x2000\n    FLAG23_COMPRESS = 0x0080\n    FLAG23_ENCRYPT = 0x0040\n    FLAG23_GROUP = 0x0020\n    FLAG24_ALTERTAG = 0x4000\n    FLAG24_ALTERFILE = 0x2000\n    FLAG24_READONLY = 0x1000\n    FLAG24_GROUPID = 0x0040\n    FLAG24_COMPRESS = 0x0008\n    FLAG24_ENCRYPT = 0x0004\n    FLAG24_UNSYNCH = 0x0002\n    FLAG24_DATALEN = 0x0001\n    GENRES = GENRES\nmutagen/_util.py\ndef read_full(fileobj, size):\n    \"\"\"Like fileobj.read but raises IOError if not all requested data is\n    returned.\n\n    If you want to distinguish IOError and the EOS case, better handle\n    the error yourself instead of using this.\n\n    Args:\n        fileobj (fileobj)\n        size (int): amount of bytes to read\n    Raises:\n        IOError: In case read fails or not enough data is read\n    \"\"\"\n\n    if size < 0:\n        raise ValueError(\"size must not be negative\")\n\n    data = fileobj.read(size)\n    if len(data) != size:\n        raise IOError\n    return data\nmutagen/id3/_util.py\nclass error(MutagenError):\n    pass\nmutagen/id3/_util.py\nclass ID3UnsupportedVersionError(error, NotImplementedError):\n    pass\nmutagen/id3/_util.py\ndef is_valid_frame_id(frame_id):\n    return frame_id.isalnum() and frame_id.isupper()\nmutagen/id3/_util.py\nclass ID3NoHeaderError(error, ValueError):\n    pass\nmutagen/_util.py\nclass DictProxy(DictMixin):\n    def __init__(self, *args, **kwargs):\n        self.__dict = {}\n        super(DictProxy, self).__init__(*args, **kwargs)\n\n    def __getitem__(self, key):\n        return self.__dict[key]\n\n    def __setitem__(self, key, value):\n        self.__dict[key] = value\n\n    def __delitem__(self, key):\n        del(self.__dict[key])\n\n    def keys(self):\n        return self.__dict.keys()\nmutagen/id3/_util.py\nclass BitPaddedInt(int, _BitPaddedMixin):\n\n    def __new__(cls, value, bits=7, bigendian=True):\n\n        mask = (1 << (bits)) - 1\n        numeric_value = 0\n        shift = 0\n\n        if isinstance(value, int):\n            if value < 0:\n                raise ValueError\n            while value:\n                numeric_value += (value & mask) << shift\n                value >>= 8\n                shift += bits\n        elif isinstance(value, bytes):\n            if bigendian:\n                value = reversed(value)\n            for byte in bytearray(value):\n                numeric_value += (byte & mask) << shift\n                shift += bits\n        else:\n            raise TypeError\n\n        self = int.__new__(BitPaddedInt, numeric_value)\n\n        self.bits = bits\n        self.bigendian = bigendian\n        return self\nmutagen/_util.py\ndef convert_error(exc_src, exc_dest):\n    \"\"\"A decorator for reraising exceptions with a different type.\n    Mostly useful for IOError.\n\n    Args:\n        exc_src (type): The source exception type\n        exc_dest (type): The target exception type.\n    \"\"\"\n\n    def wrap(func):\n\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            try:\n                return func(*args, **kwargs)\n            except exc_dest:\n                raise\n            except exc_src as err:\n                reraise(exc_dest, err, sys.exc_info()[2])\n\n        return wrapper\n\n    return wrap\nmutagen/_tags.py\nclass Tags(object):\n    \"\"\"`Tags` is the base class for many of the tag objects in Mutagen.\n\n    In many cases it has a dict like interface.\n    \"\"\"\n\n    __module__ = \"mutagen\"\n\n    def pprint(self):\n        \"\"\"\n        Returns:\n            text: tag information\n        \"\"\"\n\n        raise NotImplementedError\nmutagen/id3/_util.py\nclass ID3EncryptionUnsupportedError(error, NotImplementedError):\n    pass\nmutagen/id3/_util.py\nclass ID3JunkFrameError(error):\n    pass\nmutagen/id3/_util.py\nclass ID3SaveConfig(object):\n\n    def __init__(self, v2_version=4, v23_separator=None):\n        assert v2_version in (3, 4)\n        self.v2_version = v2_version\n        self.v23_separator = v23_separator\nmutagen/id3/_util.py\nclass unsynch(object):\n    @staticmethod\n    def decode(value):\n        fragments = bytearray(value).split(b'\\xff')\n        if len(fragments) > 1 and not fragments[-1]:\n            raise ValueError('string ended unsafe')\n\n        for f in fragments[1:]:\n            if (not f) or (f[0] >= 0xE0):\n                raise ValueError('invalid sync-safe string')\n\n            if f[0] == 0x00:\n                del f[0]\n\n        return bytes(bytearray(b'\\xff').join(fragments))\n\n    @staticmethod\n    def encode(value):\n        fragments = bytearray(value).split(b'\\xff')\n        for f in fragments[1:]:\n            if (not f) or (f[0] >= 0xE0) or (f[0] == 0x00):\n                f.insert(0, 0x00)\n        return bytes(bytearray(b'\\xff').join(fragments))\n", "answers": ["    if isinstance(frame, TextFrame):"], "length": 1608, "dataset": "repobench-p_e", "language": "python", "all_classes": null, "_id": "22cc5edeea2a251a75ec8950fd9bd0000a1dc7ee084af4ce", "pred": "```\n```\nPlease complete the code given above. The code is incomplete and there are many methods and classes defined but not implemented. The code is related to ID3 tags in MP3 files. \n\nThe code seems to be a part of the Mutagen library, which is a Python library to handle various audio formats"}
